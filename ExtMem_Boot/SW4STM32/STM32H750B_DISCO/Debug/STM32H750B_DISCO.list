
STM32H750B_DISCO.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000298  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001ad8  08000298  08000298  00010298  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000010  08001d70  08001d70  00011d70  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .init_array   00000004  08001d80  08001d80  00011d80  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .fini_array   00000004  08001d84  08001d84  00011d84  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .data         00000010  20000000  08001d88  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .bss          00000070  20000010  08001d98  00020010  2**2
                  ALLOC
  7 ._user_heap_stack 00002000  20000080  08001d98  00020080  2**0
                  ALLOC
  8 .ARM.attributes 0000002e  00000000  00000000  00020010  2**0
                  CONTENTS, READONLY
  9 .debug_line   0000b995  00000000  00000000  0002003e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 10 .debug_info   0000af14  00000000  00000000  0002b9d3  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 11 .debug_abbrev 00001b7a  00000000  00000000  000368e7  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 12 .debug_aranges 00000650  00000000  00000000  00038468  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 13 .debug_str    0017690c  00000000  00000000  00038ab8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_ranges 00000830  00000000  00000000  001af3c8  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_loc    00003124  00000000  00000000  001afbf8  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_macro  0000285c  00000000  00000000  001b2d1c  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .comment      00000050  00000000  00000000  001b5578  2**0
                  CONTENTS, READONLY
 18 .debug_frame  00000fd4  00000000  00000000  001b55c8  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

08000298 <__do_global_dtors_aux>:
 8000298:	b510      	push	{r4, lr}
 800029a:	4c05      	ldr	r4, [pc, #20]	; (80002b0 <__do_global_dtors_aux+0x18>)
 800029c:	7823      	ldrb	r3, [r4, #0]
 800029e:	b933      	cbnz	r3, 80002ae <__do_global_dtors_aux+0x16>
 80002a0:	4b04      	ldr	r3, [pc, #16]	; (80002b4 <__do_global_dtors_aux+0x1c>)
 80002a2:	b113      	cbz	r3, 80002aa <__do_global_dtors_aux+0x12>
 80002a4:	4804      	ldr	r0, [pc, #16]	; (80002b8 <__do_global_dtors_aux+0x20>)
 80002a6:	f3af 8000 	nop.w
 80002aa:	2301      	movs	r3, #1
 80002ac:	7023      	strb	r3, [r4, #0]
 80002ae:	bd10      	pop	{r4, pc}
 80002b0:	20000010 	.word	0x20000010
 80002b4:	00000000 	.word	0x00000000
 80002b8:	08001d58 	.word	0x08001d58

080002bc <frame_dummy>:
 80002bc:	b508      	push	{r3, lr}
 80002be:	4b03      	ldr	r3, [pc, #12]	; (80002cc <frame_dummy+0x10>)
 80002c0:	b11b      	cbz	r3, 80002ca <frame_dummy+0xe>
 80002c2:	4903      	ldr	r1, [pc, #12]	; (80002d0 <frame_dummy+0x14>)
 80002c4:	4803      	ldr	r0, [pc, #12]	; (80002d4 <frame_dummy+0x18>)
 80002c6:	f3af 8000 	nop.w
 80002ca:	bd08      	pop	{r3, pc}
 80002cc:	00000000 	.word	0x00000000
 80002d0:	20000014 	.word	0x20000014
 80002d4:	08001d58 	.word	0x08001d58

080002d8 <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:  
  ldr   sp, =_estack      /* set stack pointer */
 80002d8:	f8df d034 	ldr.w	sp, [pc, #52]	; 8000310 <LoopFillZerobss+0x14>

/* Copy the data segment initializers from flash to SRAM */  
  movs  r1, #0
 80002dc:	2100      	movs	r1, #0
  b  LoopCopyDataInit
 80002de:	e003      	b.n	80002e8 <LoopCopyDataInit>

080002e0 <CopyDataInit>:

CopyDataInit:
  ldr  r3, =_sidata
 80002e0:	4b0c      	ldr	r3, [pc, #48]	; (8000314 <LoopFillZerobss+0x18>)
  ldr  r3, [r3, r1]
 80002e2:	585b      	ldr	r3, [r3, r1]
  str  r3, [r0, r1]
 80002e4:	5043      	str	r3, [r0, r1]
  adds  r1, r1, #4
 80002e6:	3104      	adds	r1, #4

080002e8 <LoopCopyDataInit>:
    
LoopCopyDataInit:
  ldr  r0, =_sdata
 80002e8:	480b      	ldr	r0, [pc, #44]	; (8000318 <LoopFillZerobss+0x1c>)
  ldr  r3, =_edata
 80002ea:	4b0c      	ldr	r3, [pc, #48]	; (800031c <LoopFillZerobss+0x20>)
  adds  r2, r0, r1
 80002ec:	1842      	adds	r2, r0, r1
  cmp  r2, r3
 80002ee:	429a      	cmp	r2, r3
  bcc  CopyDataInit
 80002f0:	d3f6      	bcc.n	80002e0 <CopyDataInit>
  ldr  r2, =_sbss
 80002f2:	4a0b      	ldr	r2, [pc, #44]	; (8000320 <LoopFillZerobss+0x24>)
  b  LoopFillZerobss
 80002f4:	e002      	b.n	80002fc <LoopFillZerobss>

080002f6 <FillZerobss>:
/* Zero fill the bss segment. */  
FillZerobss:
  movs  r3, #0
 80002f6:	2300      	movs	r3, #0
  str  r3, [r2], #4
 80002f8:	f842 3b04 	str.w	r3, [r2], #4

080002fc <LoopFillZerobss>:
    
LoopFillZerobss:
  ldr  r3, = _ebss
 80002fc:	4b09      	ldr	r3, [pc, #36]	; (8000324 <LoopFillZerobss+0x28>)
  cmp  r2, r3
 80002fe:	429a      	cmp	r2, r3
  bcc  FillZerobss
 8000300:	d3f9      	bcc.n	80002f6 <FillZerobss>

/* Call the clock system initialization function.*/
  bl  SystemInit   
 8000302:	f000 fb7b 	bl	80009fc <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8000306:	f001 fd03 	bl	8001d10 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
 800030a:	f000 f80f 	bl	800032c <main>
  bx  lr    
 800030e:	4770      	bx	lr
  ldr   sp, =_estack      /* set stack pointer */
 8000310:	20020000 	.word	0x20020000
  ldr  r3, =_sidata
 8000314:	08001d88 	.word	0x08001d88
  ldr  r0, =_sdata
 8000318:	20000000 	.word	0x20000000
  ldr  r3, =_edata
 800031c:	20000010 	.word	0x20000010
  ldr  r2, =_sbss
 8000320:	20000010 	.word	0x20000010
  ldr  r3, = _ebss
 8000324:	20000080 	.word	0x20000080

08000328 <ADC3_IRQHandler>:
 * @retval None       
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
 8000328:	e7fe      	b.n	8000328 <ADC3_IRQHandler>
	...

0800032c <main>:
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
 800032c:	4b79      	ldr	r3, [pc, #484]	; (8000514 <main+0x1e8>)
 800032e:	695a      	ldr	r2, [r3, #20]
 8000330:	f412 3200 	ands.w	r2, r2, #131072	; 0x20000
  * @brief  Main program
  * @param  None
  * @retval None
  */
int main(void)
{
 8000334:	b580      	push	{r7, lr}
 8000336:	b09c      	sub	sp, #112	; 0x70
 8000338:	d111      	bne.n	800035e <main+0x32>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 800033a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800033e:	f3bf 8f6f 	isb	sy

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 8000342:	f8c3 2250 	str.w	r2, [r3, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 8000346:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800034a:	f3bf 8f6f 	isb	sy
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
 800034e:	695a      	ldr	r2, [r3, #20]
 8000350:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 8000354:	615a      	str	r2, [r3, #20]
  __ASM volatile ("dsb 0xF":::"memory");
 8000356:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 800035a:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
 800035e:	4a6d      	ldr	r2, [pc, #436]	; (8000514 <main+0x1e8>)
 8000360:	6953      	ldr	r3, [r2, #20]
 8000362:	f413 3380 	ands.w	r3, r3, #65536	; 0x10000
 8000366:	d123      	bne.n	80003b0 <main+0x84>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 8000368:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 800036c:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 8000370:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000374:	f643 74e0 	movw	r4, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000378:	f3c3 00c9 	ubfx	r0, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 800037c:	f3c3 334e 	ubfx	r3, r3, #13, #15
 8000380:	015b      	lsls	r3, r3, #5
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000382:	ea03 0604 	and.w	r6, r3, r4
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 8000386:	4601      	mov	r1, r0
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 8000388:	ea46 7581 	orr.w	r5, r6, r1, lsl #30
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 800038c:	3901      	subs	r1, #1
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
 800038e:	f8c2 5260 	str.w	r5, [r2, #608]	; 0x260
      } while (ways-- != 0U);
 8000392:	d2f9      	bcs.n	8000388 <main+0x5c>
    } while(sets-- != 0U);
 8000394:	3b20      	subs	r3, #32
 8000396:	f113 0f20 	cmn.w	r3, #32
 800039a:	d1f2      	bne.n	8000382 <main+0x56>
 800039c:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
 80003a0:	6953      	ldr	r3, [r2, #20]
 80003a2:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80003a6:	6153      	str	r3, [r2, #20]
 80003a8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80003ac:	f3bf 8f6f 	isb	sy
  /* STM32H7xx HAL library initialization:
       - Configure the Systick to generate an interrupt each 1 msec
       - Set NVIC Group Priority to 4
       - Global MSP (MCU Support Package) initialization
     */
  HAL_Init();
 80003b0:	f000 fb8c 	bl	8000acc <HAL_Init>
  RCC_ClkInitTypeDef RCC_ClkInitStruct;
  RCC_OscInitTypeDef RCC_OscInitStruct;
  HAL_StatusTypeDef ret = HAL_OK;

  /*!< Supply configuration update enable */
   HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY); /* PWR set to LDO for the STM32H750B-DISCO board */
 80003b4:	2002      	movs	r0, #2
 80003b6:	f000 fd6b 	bl	8000e90 <HAL_PWREx_ConfigSupply>

  /* The voltage scaling allows optimizing the power consumption when the device is
     clocked below the maximum system frequency, to update the voltage scaling value
     regarding system frequency refer to product datasheet.  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
 80003ba:	2300      	movs	r3, #0
 80003bc:	9300      	str	r3, [sp, #0]
 80003be:	4b56      	ldr	r3, [pc, #344]	; (8000518 <main+0x1ec>)
 80003c0:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 80003c2:	f022 0201 	bic.w	r2, r2, #1
 80003c6:	62da      	str	r2, [r3, #44]	; 0x2c
 80003c8:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80003ca:	f003 0301 	and.w	r3, r3, #1
 80003ce:	9300      	str	r3, [sp, #0]
 80003d0:	4b52      	ldr	r3, [pc, #328]	; (800051c <main+0x1f0>)
 80003d2:	699a      	ldr	r2, [r3, #24]
 80003d4:	f442 4240 	orr.w	r2, r2, #49152	; 0xc000
 80003d8:	619a      	str	r2, [r3, #24]
 80003da:	699a      	ldr	r2, [r3, #24]
 80003dc:	f402 4240 	and.w	r2, r2, #49152	; 0xc000
 80003e0:	9200      	str	r2, [sp, #0]
 80003e2:	9a00      	ldr	r2, [sp, #0]

  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
 80003e4:	699a      	ldr	r2, [r3, #24]
 80003e6:	0492      	lsls	r2, r2, #18
 80003e8:	d5fc      	bpl.n	80003e4 <main+0xb8>

  /* Enable HSE Oscillator and activate PLL with HSE as source */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
 80003ea:	2300      	movs	r3, #0
  RCC_OscInitStruct.CSIState = RCC_CSI_OFF;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 80003ec:	2202      	movs	r2, #2
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 80003ee:	2701      	movs	r7, #1
 80003f0:	f44f 3680 	mov.w	r6, #65536	; 0x10000
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;

  RCC_OscInitStruct.PLL.PLLM = 5;
  RCC_OscInitStruct.PLL.PLLN = 160;
 80003f4:	f04f 0e05 	mov.w	lr, #5
 80003f8:	21a0      	movs	r1, #160	; 0xa0
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLQ = 4;
 80003fa:	2504      	movs	r5, #4

  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
 80003fc:	2408      	movs	r4, #8
  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 80003fe:	a809      	add	r0, sp, #36	; 0x24
  RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
 8000400:	930c      	str	r3, [sp, #48]	; 0x30
  RCC_OscInitStruct.CSIState = RCC_CSI_OFF;
 8000402:	9310      	str	r3, [sp, #64]	; 0x40
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
 8000404:	931b      	str	r3, [sp, #108]	; 0x6c
  RCC_OscInitStruct.PLL.PLLP = 2;
 8000406:	9216      	str	r2, [sp, #88]	; 0x58
  RCC_OscInitStruct.PLL.PLLR = 2;
 8000408:	9218      	str	r2, [sp, #96]	; 0x60
  RCC_OscInitStruct.PLL.PLLQ = 4;
 800040a:	9517      	str	r5, [sp, #92]	; 0x5c
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
 800040c:	931a      	str	r3, [sp, #104]	; 0x68
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
 800040e:	9419      	str	r4, [sp, #100]	; 0x64
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8000410:	e9cd 7609 	strd	r7, r6, [sp, #36]	; 0x24
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8000414:	e9cd 2212 	strd	r2, r2, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLN = 160;
 8000418:	e9cd e114 	strd	lr, r1, [sp, #80]	; 0x50
  ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
 800041c:	f001 f820 	bl	8001460 <HAL_RCC_OscConfig>
  if(ret != HAL_OK)
 8000420:	b100      	cbz	r0, 8000424 <main+0xf8>
  while(1)
 8000422:	e7fe      	b.n	8000422 <main+0xf6>

  /* Select PLL as system clock source and configure  bus clocks dividers */
  RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 | \
                                 RCC_CLOCKTYPE_PCLK2  | RCC_CLOCKTYPE_D3PCLK1);

  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000424:	2303      	movs	r3, #3
 8000426:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
 800042a:	f44f 6280 	mov.w	r2, #1024	; 0x400
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
 800042e:	4629      	mov	r1, r5
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000430:	e9cd c301 	strd	ip, r3, [sp, #4]
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
 8000434:	2340      	movs	r3, #64	; 0x40
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
 8000436:	e9cd 0403 	strd	r0, r4, [sp, #12]
  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
 800043a:	a801      	add	r0, sp, #4
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
 800043c:	e9cd 3305 	strd	r3, r3, [sp, #20]
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
 8000440:	e9cd 2307 	strd	r2, r3, [sp, #28]
  ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
 8000444:	f001 fb3e 	bl	8001ac4 <HAL_RCC_ClockConfig>
  if(ret != HAL_OK)
 8000448:	b100      	cbz	r0, 800044c <main+0x120>
  while(1)
 800044a:	e7fe      	b.n	800044a <main+0x11e>
  status |= QSPI_Startup(QSPI_MODE);
 800044c:	f000 f9d2 	bl	80007f4 <QSPI_Startup>
  if(Memory_Startup() != MEMORY_OK)
 8000450:	4604      	mov	r4, r0
 8000452:	b100      	cbz	r0, 8000456 <main+0x12a>
  while(1)
 8000454:	e7fe      	b.n	8000454 <main+0x128>
static void MPU_Config (void)
{
  MPU_Region_InitTypeDef MPU_InitStruct;

  /* Disable the MPU */
  HAL_MPU_Disable();
 8000456:	f000 fbe5 	bl	8000c24 <HAL_MPU_Disable>
  MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.Number = MPU_REGION_NUMBER0;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.SubRegionDisable = 0x87;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
 800045a:	f248 721f 	movw	r2, #34591	; 0x871f
 800045e:	f240 1301 	movw	r3, #257	; 0x101

  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8000462:	a809      	add	r0, sp, #36	; 0x24
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8000464:	f8ad 7024 	strh.w	r7, [sp, #36]	; 0x24
  MPU_InitStruct.BaseAddress = 0x00;
 8000468:	940a      	str	r4, [sp, #40]	; 0x28
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
 800046a:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 800046e:	f000 fbf7 	bl	8000c60 <HAL_MPU_ConfigRegion>
#endif
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
#endif
#if (CODE_AREA == USE_QSPI) || (BINARY_AREA == USE_SPI_NOR)
  /* Configure the MPU QSPI flash */
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 8000472:	f240 2301 	movw	r3, #513	; 0x201
  MPU_InitStruct.BaseAddress = 0x90000000;
  MPU_InitStruct.Size = MPU_REGION_SIZE_128MB;
 8000476:	f04f 4110 	mov.w	r1, #2415919104	; 0x90000000
  MPU_InitStruct.Number = MPU_REGION_NUMBER2;
  MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
  MPU_InitStruct.SubRegionDisable = 0x0;
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
  
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 800047a:	a809      	add	r0, sp, #36	; 0x24
  MPU_InitStruct.Enable = MPU_REGION_ENABLE;
 800047c:	f8ad 3024 	strh.w	r3, [sp, #36]	; 0x24
  MPU_InitStruct.Size = MPU_REGION_SIZE_128MB;
 8000480:	4b27      	ldr	r3, [pc, #156]	; (8000520 <main+0x1f4>)
  MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
 8000482:	960c      	str	r6, [sp, #48]	; 0x30
  MPU_InitStruct.Size = MPU_REGION_SIZE_128MB;
 8000484:	e9cd 130a 	strd	r1, r3, [sp, #40]	; 0x28
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
 8000488:	f000 fbea 	bl	8000c60 <HAL_MPU_ConfigRegion>
#endif
  /* Enable the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
 800048c:	4628      	mov	r0, r5
 800048e:	f000 fbd7 	bl	8000c40 <HAL_MPU_Enable>
  __ASM volatile ("dsb 0xF":::"memory");
 8000492:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000496:	f3bf 8f6f 	isb	sy
    SCB->CCR &= ~(uint32_t)SCB_CCR_IC_Msk;  /* disable I-Cache */
 800049a:	4a1e      	ldr	r2, [pc, #120]	; (8000514 <main+0x1e8>)
 800049c:	6953      	ldr	r3, [r2, #20]
 800049e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 80004a2:	6153      	str	r3, [r2, #20]
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
 80004a4:	f8c2 4250 	str.w	r4, [r2, #592]	; 0x250
  __ASM volatile ("dsb 0xF":::"memory");
 80004a8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80004ac:	f3bf 8f6f 	isb	sy
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
 80004b0:	f8c2 4084 	str.w	r4, [r2, #132]	; 0x84
  __ASM volatile ("dsb 0xF":::"memory");
 80004b4:	f3bf 8f4f 	dsb	sy
    __DSB();

    SCB->CCR &= ~(uint32_t)SCB_CCR_DC_Msk;  /* disable D-Cache */
 80004b8:	6953      	ldr	r3, [r2, #20]
 80004ba:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80004be:	6153      	str	r3, [r2, #20]
 80004c0:	f3bf 8f4f 	dsb	sy
    __DSB();

    ccsidr = SCB->CCSIDR;
 80004c4:	f8d2 3080 	ldr.w	r3, [r2, #128]	; 0x80
                                            /* clean & invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
      do {
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 80004c8:	f643 74e0 	movw	r4, #16352	; 0x3fe0
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80004cc:	f3c3 00c9 	ubfx	r0, r3, #3, #10
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
 80004d0:	f3c3 334e 	ubfx	r3, r3, #13, #15
 80004d4:	015b      	lsls	r3, r3, #5
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 80004d6:	ea03 0604 	and.w	r6, r3, r4
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
 80004da:	4601      	mov	r1, r0
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 80004dc:	ea46 7581 	orr.w	r5, r6, r1, lsl #30
                       ((ways << SCB_DCCISW_WAY_Pos) & SCB_DCCISW_WAY_Msk)  );
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
 80004e0:	3901      	subs	r1, #1
        SCB->DCCISW = (((sets << SCB_DCCISW_SET_Pos) & SCB_DCCISW_SET_Msk) |
 80004e2:	f8c2 5274 	str.w	r5, [r2, #628]	; 0x274
      } while (ways-- != 0U);
 80004e6:	d2f9      	bcs.n	80004dc <main+0x1b0>
    } while(sets-- != 0U);
 80004e8:	3b20      	subs	r3, #32
 80004ea:	f113 0f20 	cmn.w	r3, #32
 80004ee:	d1f2      	bne.n	80004d6 <main+0x1aa>
 80004f0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 80004f4:	f3bf 8f6f 	isb	sy
  SysTick->CTRL = 0;
 80004f8:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
 80004fc:	2200      	movs	r2, #0
  JumpToApplication = (pFunction) (*(__IO uint32_t*) (APPLICATION_ADDRESS + 4));
 80004fe:	4909      	ldr	r1, [pc, #36]	; (8000524 <main+0x1f8>)
  SysTick->CTRL = 0;
 8000500:	611a      	str	r2, [r3, #16]
  JumpToApplication = (pFunction) (*(__IO uint32_t*) (APPLICATION_ADDRESS + 4));
 8000502:	f04f 4210 	mov.w	r2, #2415919104	; 0x90000000
 8000506:	6853      	ldr	r3, [r2, #4]
  __set_MSP(*(__IO uint32_t*) APPLICATION_ADDRESS);
 8000508:	6812      	ldr	r2, [r2, #0]
  JumpToApplication = (pFunction) (*(__IO uint32_t*) (APPLICATION_ADDRESS + 4));
 800050a:	600b      	str	r3, [r1, #0]
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 800050c:	f382 8808 	msr	MSP, r2
  JumpToApplication();
 8000510:	4798      	blx	r3
  while(1)
 8000512:	e7fe      	b.n	8000512 <main+0x1e6>
 8000514:	e000ed00 	.word	0xe000ed00
 8000518:	58000400 	.word	0x58000400
 800051c:	58024800 	.word	0x58024800
 8000520:	0300001a 	.word	0x0300001a
 8000524:	2000002c 	.word	0x2000002c

08000528 <QSPI_MspInit>:
{
  GPIO_InitTypeDef gpio_init_structure;

  /*##-1- Enable peripherals and GPIO Clocks #################################*/
  /* Enable the QuadSPI memory interface clock */
  QSPI_CLK_ENABLE();
 8000528:	4b7b      	ldr	r3, [pc, #492]	; (8000718 <QSPI_MspInit+0x1f0>)
 800052a:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
 800052e:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
{
 8000532:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  QSPI_CLK_ENABLE();
 8000536:	f8c3 20d4 	str.w	r2, [r3, #212]	; 0xd4
{
 800053a:	b091      	sub	sp, #68	; 0x44
  QSPI_CLK_ENABLE();
 800053c:	f8d3 20d4 	ldr.w	r2, [r3, #212]	; 0xd4
  /* QSPI CLK GPIO pin configuration  */
  gpio_init_structure.Pin       = QSPI_CLK_PIN;
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
  gpio_init_structure.Speed     = GPIO_SPEED_FREQ_VERY_HIGH;
  gpio_init_structure.Pull      = GPIO_NOPULL;
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
 8000540:	2409      	movs	r4, #9
  HAL_GPIO_Init(QSPI_CLK_GPIO_PORT, &gpio_init_structure);
 8000542:	4d76      	ldr	r5, [pc, #472]	; (800071c <QSPI_MspInit+0x1f4>)
  gpio_init_structure.Pull      = GPIO_NOPULL;
 8000544:	2600      	movs	r6, #0
  QSPI_CLK_ENABLE();
 8000546:	f402 4280 	and.w	r2, r2, #16384	; 0x4000

  /* QSPI CS GPIO pin configuration  */
  gpio_init_structure.Pin       = QSPI_BK1_CS_PIN;
  gpio_init_structure.Pull      = GPIO_PULLUP;
  gpio_init_structure.Alternate = GPIO_AF10_QUADSPI;
  HAL_GPIO_Init(QSPI_BK1_CS_GPIO_PORT, &gpio_init_structure);
 800054a:	4f75      	ldr	r7, [pc, #468]	; (8000720 <QSPI_MspInit+0x1f8>)
  HAL_GPIO_Init(QSPI_CLK_GPIO_PORT, &gpio_init_structure);
 800054c:	a90b      	add	r1, sp, #44	; 0x2c
 800054e:	4628      	mov	r0, r5
  QSPI_CLK_ENABLE();
 8000550:	9200      	str	r2, [sp, #0]
  gpio_init_structure.Pin       = QSPI_BK1_CS_PIN;
 8000552:	f04f 0840 	mov.w	r8, #64	; 0x40
  QSPI_CLK_ENABLE();
 8000556:	9a00      	ldr	r2, [sp, #0]
  gpio_init_structure.Alternate = GPIO_AF10_QUADSPI;
 8000558:	f04f 0b0a 	mov.w	fp, #10
  QSPI_FORCE_RESET();
 800055c:	6fda      	ldr	r2, [r3, #124]	; 0x7c
  gpio_init_structure.Pin       = QSPI_BK2_D0_PIN;
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
  HAL_GPIO_Init(QSPI_BK2_D0_GPIO_PORT, &gpio_init_structure);

  /* QSPI D1 GPIO pin configuration  */
  gpio_init_structure.Pin       = QSPI_BK1_D1_PIN;
 800055e:	f44f 7900 	mov.w	r9, #512	; 0x200
  HAL_GPIO_Init(QSPI_BK2_D0_GPIO_PORT, &gpio_init_structure);
 8000562:	f8df a1c4 	ldr.w	sl, [pc, #452]	; 8000728 <QSPI_MspInit+0x200>
  QSPI_FORCE_RESET();
 8000566:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800056a:	67da      	str	r2, [r3, #124]	; 0x7c
  QSPI_RELEASE_RESET();
 800056c:	6fda      	ldr	r2, [r3, #124]	; 0x7c
 800056e:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8000572:	67da      	str	r2, [r3, #124]	; 0x7c
  QSPI_CLK_GPIO_CLK_ENABLE();
 8000574:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8000578:	f042 0220 	orr.w	r2, r2, #32
 800057c:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 8000580:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8000584:	f002 0220 	and.w	r2, r2, #32
 8000588:	9201      	str	r2, [sp, #4]
 800058a:	9a01      	ldr	r2, [sp, #4]
  QSPI_BK1_D0_GPIO_CLK_ENABLE();
 800058c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8000590:	f042 0208 	orr.w	r2, r2, #8
 8000594:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 8000598:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 800059c:	f002 0208 	and.w	r2, r2, #8
 80005a0:	9202      	str	r2, [sp, #8]
 80005a2:	9a02      	ldr	r2, [sp, #8]
  QSPI_BK1_D1_GPIO_CLK_ENABLE();
 80005a4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80005a8:	f042 0220 	orr.w	r2, r2, #32
 80005ac:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 80005b0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80005b4:	f002 0220 	and.w	r2, r2, #32
 80005b8:	9203      	str	r2, [sp, #12]
 80005ba:	9a03      	ldr	r2, [sp, #12]
  QSPI_BK1_D2_GPIO_CLK_ENABLE();
 80005bc:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80005c0:	f042 0220 	orr.w	r2, r2, #32
 80005c4:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 80005c8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80005cc:	f002 0220 	and.w	r2, r2, #32
 80005d0:	9204      	str	r2, [sp, #16]
 80005d2:	9a04      	ldr	r2, [sp, #16]
  QSPI_BK1_D3_GPIO_CLK_ENABLE();
 80005d4:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80005d8:	f042 0220 	orr.w	r2, r2, #32
 80005dc:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 80005e0:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80005e4:	f002 0220 	and.w	r2, r2, #32
 80005e8:	9205      	str	r2, [sp, #20]
 80005ea:	9a05      	ldr	r2, [sp, #20]
  QSPI_BK2_CS_GPIO_CLK_ENABLE();
 80005ec:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80005f0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 80005f4:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 80005f8:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 80005fc:	f002 0240 	and.w	r2, r2, #64	; 0x40
 8000600:	9206      	str	r2, [sp, #24]
 8000602:	9a06      	ldr	r2, [sp, #24]
  QSPI_BK2_D0_GPIO_CLK_ENABLE();
 8000604:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8000608:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800060c:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 8000610:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8000614:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8000618:	9207      	str	r2, [sp, #28]
 800061a:	9a07      	ldr	r2, [sp, #28]
  QSPI_BK2_D1_GPIO_CLK_ENABLE();
 800061c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8000620:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8000624:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 8000628:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 800062c:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8000630:	9208      	str	r2, [sp, #32]
 8000632:	9a08      	ldr	r2, [sp, #32]
  QSPI_BK2_D2_GPIO_CLK_ENABLE();
 8000634:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8000638:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800063c:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
 8000640:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8000644:	f002 0240 	and.w	r2, r2, #64	; 0x40
 8000648:	9209      	str	r2, [sp, #36]	; 0x24
 800064a:	9a09      	ldr	r2, [sp, #36]	; 0x24
  QSPI_BK2_D3_GPIO_CLK_ENABLE();
 800064c:	f8d3 20e0 	ldr.w	r2, [r3, #224]	; 0xe0
 8000650:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000654:	f8c3 20e0 	str.w	r2, [r3, #224]	; 0xe0
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 8000658:	f44f 6280 	mov.w	r2, #1024	; 0x400
  QSPI_BK2_D3_GPIO_CLK_ENABLE();
 800065c:	f8d3 30e0 	ldr.w	r3, [r3, #224]	; 0xe0
 8000660:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8000664:	930a      	str	r3, [sp, #40]	; 0x28
 8000666:	9b0a      	ldr	r3, [sp, #40]	; 0x28
  gpio_init_structure.Mode      = GPIO_MODE_AF_PP;
 8000668:	2302      	movs	r3, #2
 800066a:	e9cd 230b 	strd	r2, r3, [sp, #44]	; 0x2c
  gpio_init_structure.Pull      = GPIO_NOPULL;
 800066e:	2303      	movs	r3, #3
 8000670:	e9cd 630d 	strd	r6, r3, [sp, #52]	; 0x34
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
 8000674:	940f      	str	r4, [sp, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_CLK_GPIO_PORT, &gpio_init_structure);
 8000676:	f000 fb1f 	bl	8000cb8 <HAL_GPIO_Init>
  gpio_init_structure.Pull      = GPIO_PULLUP;
 800067a:	2301      	movs	r3, #1
  HAL_GPIO_Init(QSPI_BK1_CS_GPIO_PORT, &gpio_init_structure);
 800067c:	a90b      	add	r1, sp, #44	; 0x2c
 800067e:	4638      	mov	r0, r7
  gpio_init_structure.Pin       = QSPI_BK1_CS_PIN;
 8000680:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
  gpio_init_structure.Pull      = GPIO_PULLUP;
 8000684:	930d      	str	r3, [sp, #52]	; 0x34
  gpio_init_structure.Alternate = GPIO_AF10_QUADSPI;
 8000686:	f8cd b03c 	str.w	fp, [sp, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_BK1_CS_GPIO_PORT, &gpio_init_structure);
 800068a:	f000 fb15 	bl	8000cb8 <HAL_GPIO_Init>
  gpio_init_structure.Pin       = QSPI_BK1_D0_PIN;
 800068e:	f44f 6300 	mov.w	r3, #2048	; 0x800
  HAL_GPIO_Init(QSPI_BK1_D0_GPIO_PORT, &gpio_init_structure);
 8000692:	a90b      	add	r1, sp, #44	; 0x2c
 8000694:	4823      	ldr	r0, [pc, #140]	; (8000724 <QSPI_MspInit+0x1fc>)
  gpio_init_structure.Pin       = QSPI_BK1_D0_PIN;
 8000696:	930b      	str	r3, [sp, #44]	; 0x2c
  gpio_init_structure.Pull      = GPIO_NOPULL;
 8000698:	960d      	str	r6, [sp, #52]	; 0x34
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
 800069a:	940f      	str	r4, [sp, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_BK1_D0_GPIO_PORT, &gpio_init_structure);
 800069c:	f000 fb0c 	bl	8000cb8 <HAL_GPIO_Init>
  gpio_init_structure.Pin       = QSPI_BK2_D0_PIN;
 80006a0:	2304      	movs	r3, #4
  HAL_GPIO_Init(QSPI_BK2_D0_GPIO_PORT, &gpio_init_structure);
 80006a2:	a90b      	add	r1, sp, #44	; 0x2c
 80006a4:	4650      	mov	r0, sl
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
 80006a6:	940f      	str	r4, [sp, #60]	; 0x3c
  gpio_init_structure.Pin       = QSPI_BK2_D0_PIN;
 80006a8:	930b      	str	r3, [sp, #44]	; 0x2c
  HAL_GPIO_Init(QSPI_BK2_D0_GPIO_PORT, &gpio_init_structure);
 80006aa:	f000 fb05 	bl	8000cb8 <HAL_GPIO_Init>
  gpio_init_structure.Alternate = GPIO_AF10_QUADSPI;
  HAL_GPIO_Init(QSPI_BK1_D1_GPIO_PORT, &gpio_init_structure);
 80006ae:	a90b      	add	r1, sp, #44	; 0x2c
 80006b0:	4628      	mov	r0, r5
  gpio_init_structure.Pin       = QSPI_BK1_D1_PIN;
 80006b2:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
  gpio_init_structure.Alternate = GPIO_AF10_QUADSPI;
 80006b6:	f8cd b03c 	str.w	fp, [sp, #60]	; 0x3c
  HAL_GPIO_Init(QSPI_BK1_D1_GPIO_PORT, &gpio_init_structure);
 80006ba:	f000 fafd 	bl	8000cb8 <HAL_GPIO_Init>

  gpio_init_structure.Pin       = QSPI_BK2_D1_PIN;
 80006be:	2308      	movs	r3, #8
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
  HAL_GPIO_Init(QSPI_BK2_D1_GPIO_PORT, &gpio_init_structure);
 80006c0:	a90b      	add	r1, sp, #44	; 0x2c
 80006c2:	4650      	mov	r0, sl
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
 80006c4:	940f      	str	r4, [sp, #60]	; 0x3c
  gpio_init_structure.Pin       = QSPI_BK2_D1_PIN;
 80006c6:	930b      	str	r3, [sp, #44]	; 0x2c
  HAL_GPIO_Init(QSPI_BK2_D1_GPIO_PORT, &gpio_init_structure);
 80006c8:	f000 faf6 	bl	8000cb8 <HAL_GPIO_Init>

  /* QSPI D2 GPIO pin configuration  */
  gpio_init_structure.Pin       = QSPI_BK1_D2_PIN;
 80006cc:	2380      	movs	r3, #128	; 0x80
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
  HAL_GPIO_Init(QSPI_BK1_D2_GPIO_PORT, &gpio_init_structure);
 80006ce:	a90b      	add	r1, sp, #44	; 0x2c
 80006d0:	4628      	mov	r0, r5
  gpio_init_structure.Alternate = GPIO_AF9_QUADSPI;
 80006d2:	940f      	str	r4, [sp, #60]	; 0x3c
  gpio_init_structure.Pin       = QSPI_BK1_D2_PIN;
 80006d4:	930b      	str	r3, [sp, #44]	; 0x2c
  HAL_GPIO_Init(QSPI_BK1_D2_GPIO_PORT, &gpio_init_structure);
 80006d6:	f000 faef 	bl	8000cb8 <HAL_GPIO_Init>

  gpio_init_structure.Pin       = QSPI_BK2_D2_PIN;
  HAL_GPIO_Init(QSPI_BK2_D2_GPIO_PORT, &gpio_init_structure);
 80006da:	a90b      	add	r1, sp, #44	; 0x2c
 80006dc:	4638      	mov	r0, r7
  gpio_init_structure.Pin       = QSPI_BK2_D2_PIN;
 80006de:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
  HAL_GPIO_Init(QSPI_BK2_D2_GPIO_PORT, &gpio_init_structure);
 80006e2:	f000 fae9 	bl	8000cb8 <HAL_GPIO_Init>

  /* QSPI D3 GPIO pin configuration  */
  gpio_init_structure.Pin       = QSPI_BK1_D3_PIN;
  HAL_GPIO_Init(QSPI_BK1_D3_GPIO_PORT, &gpio_init_structure);
 80006e6:	a90b      	add	r1, sp, #44	; 0x2c
 80006e8:	4628      	mov	r0, r5
  gpio_init_structure.Pin       = QSPI_BK1_D3_PIN;
 80006ea:	f8cd 802c 	str.w	r8, [sp, #44]	; 0x2c
  HAL_GPIO_Init(QSPI_BK1_D3_GPIO_PORT, &gpio_init_structure);
 80006ee:	f000 fae3 	bl	8000cb8 <HAL_GPIO_Init>

  gpio_init_structure.Pin       = QSPI_BK2_D3_PIN;
 80006f2:	f44f 4380 	mov.w	r3, #16384	; 0x4000
  HAL_GPIO_Init(QSPI_BK2_D3_GPIO_PORT, &gpio_init_structure);
 80006f6:	a90b      	add	r1, sp, #44	; 0x2c
 80006f8:	4638      	mov	r0, r7
  gpio_init_structure.Pin       = QSPI_BK2_D3_PIN;
 80006fa:	930b      	str	r3, [sp, #44]	; 0x2c
  HAL_GPIO_Init(QSPI_BK2_D3_GPIO_PORT, &gpio_init_structure);
 80006fc:	f000 fadc 	bl	8000cb8 <HAL_GPIO_Init>

  /*##-3- Configure the NVIC for QSPI #########################################*/
  /* NVIC configuration for QSPI interrupt */
  HAL_NVIC_SetPriority(QUADSPI_IRQn, 0x0F, 0);
 8000700:	4632      	mov	r2, r6
 8000702:	210f      	movs	r1, #15
 8000704:	205c      	movs	r0, #92	; 0x5c
 8000706:	f000 fa39 	bl	8000b7c <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(QUADSPI_IRQn);
 800070a:	205c      	movs	r0, #92	; 0x5c
 800070c:	f000 fa68 	bl	8000be0 <HAL_NVIC_EnableIRQ>

}
 8000710:	b011      	add	sp, #68	; 0x44
 8000712:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000716:	bf00      	nop
 8000718:	58024400 	.word	0x58024400
 800071c:	58021400 	.word	0x58021400
 8000720:	58021800 	.word	0x58021800
 8000724:	58020c00 	.word	0x58020c00
 8000728:	58021c00 	.word	0x58021c00

0800072c <QSPI_AutoPollingMemReady.constprop.0>:
  * @brief  This function read the SR of the memory and wait the EOP.
  * @param  hqspi: QSPI handle
  * @param  Timeout
  * @retval None
  */
static uint32_t QSPI_AutoPollingMemReady(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
 800072c:	b500      	push	{lr}
{
  QSPI_CommandTypeDef     s_command;
  QSPI_AutoPollingTypeDef s_config;

  /* Configure automatic polling mode to wait for memory ready */
  s_command.InstructionMode   = QSPI_INSTRUCTION_4_LINES;
 800072e:	f44f 7340 	mov.w	r3, #768	; 0x300
static uint32_t QSPI_AutoPollingMemReady(QSPI_HandleTypeDef *hqspi, uint32_t Timeout)
 8000732:	b095      	sub	sp, #84	; 0x54
  s_command.Instruction       = MT25TL01G_READ_STATUS_REG_CMD;
  s_command.AddressMode       = QSPI_ADDRESS_NONE;
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode          = QSPI_DATA_4_LINES;
 8000734:	f04f 7240 	mov.w	r2, #50331648	; 0x3000000
  s_config.Interval        = 0x10;
  s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;
  s_config.Mask            = MT25TL01G_SR_WIP | (MT25TL01G_SR_WIP <<8);
  s_config.StatusBytesSize = 2;

  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, Timeout) != HAL_OK)
 8000738:	4811      	ldr	r0, [pc, #68]	; (8000780 <QSPI_AutoPollingMemReady.constprop.0+0x54>)
  s_command.InstructionMode   = QSPI_INSTRUCTION_4_LINES;
 800073a:	930c      	str	r3, [sp, #48]	; 0x30
  s_command.Instruction       = MT25TL01G_READ_STATUS_REG_CMD;
 800073c:	2305      	movs	r3, #5
  s_command.DataMode          = QSPI_DATA_4_LINES;
 800073e:	920f      	str	r2, [sp, #60]	; 0x3c
  s_command.DummyCycles       = 2;
 8000740:	2202      	movs	r2, #2
  s_command.Instruction       = MT25TL01G_READ_STATUS_REG_CMD;
 8000742:	9306      	str	r3, [sp, #24]
  s_command.AddressMode       = QSPI_ADDRESS_NONE;
 8000744:	2300      	movs	r3, #0
  s_command.DummyCycles       = 2;
 8000746:	920b      	str	r2, [sp, #44]	; 0x2c
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, Timeout) != HAL_OK)
 8000748:	a906      	add	r1, sp, #24
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 800074a:	9313      	str	r3, [sp, #76]	; 0x4c
  s_config.Match           = 0;
 800074c:	9300      	str	r3, [sp, #0]
  s_config.MatchMode       = QSPI_MATCH_MODE_AND;
 800074e:	9304      	str	r3, [sp, #16]
  s_config.StatusBytesSize = 2;
 8000750:	9203      	str	r2, [sp, #12]
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, Timeout) != HAL_OK)
 8000752:	466a      	mov	r2, sp
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 8000754:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
 8000758:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
  s_config.Interval        = 0x10;
 800075c:	2310      	movs	r3, #16
 800075e:	9302      	str	r3, [sp, #8]
  s_config.AutomaticStop   = QSPI_AUTOMATIC_STOP_ENABLE;
 8000760:	f44f 0380 	mov.w	r3, #4194304	; 0x400000
 8000764:	9305      	str	r3, [sp, #20]
  s_config.Mask            = MT25TL01G_SR_WIP | (MT25TL01G_SR_WIP <<8);
 8000766:	f240 1301 	movw	r3, #257	; 0x101
 800076a:	9301      	str	r3, [sp, #4]
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, Timeout) != HAL_OK)
 800076c:	f241 3388 	movw	r3, #5000	; 0x1388
 8000770:	f000 fde5 	bl	800133e <HAL_QSPI_AutoPolling>
  {
    return MEMORY_ERROR;
  }

  return MEMORY_OK;
}
 8000774:	3800      	subs	r0, #0
 8000776:	bf18      	it	ne
 8000778:	2001      	movne	r0, #1
 800077a:	b015      	add	sp, #84	; 0x54
 800077c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000780:	20000030 	.word	0x20000030

08000784 <QSPI_WriteEnable.constprop.0>:
static uint32_t QSPI_WriteEnable(QSPI_HandleTypeDef *hqspi)
 8000784:	b500      	push	{lr}
  s_command.InstructionMode   = QSPI_INSTRUCTION_4_LINES;
 8000786:	f44f 7340 	mov.w	r3, #768	; 0x300
static uint32_t QSPI_WriteEnable(QSPI_HandleTypeDef *hqspi)
 800078a:	b095      	sub	sp, #84	; 0x54
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800078c:	f241 3288 	movw	r2, #5000	; 0x1388
 8000790:	4817      	ldr	r0, [pc, #92]	; (80007f0 <QSPI_WriteEnable.constprop.0+0x6c>)
  s_command.InstructionMode   = QSPI_INSTRUCTION_4_LINES;
 8000792:	930c      	str	r3, [sp, #48]	; 0x30
  s_command.Instruction       = MT25TL01G_WRITE_ENABLE_CMD;
 8000794:	2306      	movs	r3, #6
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000796:	a906      	add	r1, sp, #24
  s_command.Instruction       = MT25TL01G_WRITE_ENABLE_CMD;
 8000798:	9306      	str	r3, [sp, #24]
  s_command.AddressMode       = QSPI_ADDRESS_NONE;
 800079a:	2300      	movs	r3, #0
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 800079c:	e9cd 330d 	strd	r3, r3, [sp, #52]	; 0x34
  s_command.DataMode          = QSPI_DATA_NONE;
 80007a0:	930f      	str	r3, [sp, #60]	; 0x3c
  s_command.DummyCycles       = 0;
 80007a2:	930b      	str	r3, [sp, #44]	; 0x2c
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 80007a4:	9313      	str	r3, [sp, #76]	; 0x4c
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
 80007a6:	e9cd 3311 	strd	r3, r3, [sp, #68]	; 0x44
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80007aa:	f000 fccd 	bl	8001148 <HAL_QSPI_Command>
 80007ae:	b9e8      	cbnz	r0, 80007ec <QSPI_WriteEnable.constprop.0+0x68>
  s_config.Match           = MT25TL01G_SR_WREN | (MT25TL01G_SR_WREN << 8);
 80007b0:	f240 2302 	movw	r3, #514	; 0x202
  s_config.Interval        = 0x10;
 80007b4:	2202      	movs	r2, #2
  s_command.Instruction    = MT25TL01G_READ_STATUS_REG_CMD;
 80007b6:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
  s_config.MatchMode       = QSPI_MATCH_MODE_AND;
 80007ba:	9004      	str	r0, [sp, #16]
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80007bc:	480c      	ldr	r0, [pc, #48]	; (80007f0 <QSPI_WriteEnable.constprop.0+0x6c>)
  s_config.Mask            = MT25TL01G_SR_WREN | (MT25TL01G_SR_WREN << 8);
 80007be:	e9cd 3300 	strd	r3, r3, [sp]
  s_config.Interval        = 0x10;
 80007c2:	2310      	movs	r3, #16
 80007c4:	e9cd 3202 	strd	r3, r2, [sp, #8]
  s_command.Instruction    = MT25TL01G_READ_STATUS_REG_CMD;
 80007c8:	2305      	movs	r3, #5
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80007ca:	466a      	mov	r2, sp
  s_command.Instruction    = MT25TL01G_READ_STATUS_REG_CMD;
 80007cc:	e9cd 1305 	strd	r1, r3, [sp, #20]
  s_command.DataMode       = QSPI_DATA_4_LINES;
 80007d0:	f04f 7340 	mov.w	r3, #50331648	; 0x3000000
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80007d4:	a906      	add	r1, sp, #24
  s_command.DataMode       = QSPI_DATA_4_LINES;
 80007d6:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_QSPI_AutoPolling(hqspi, &s_command, &s_config, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80007d8:	f241 3388 	movw	r3, #5000	; 0x1388
 80007dc:	f000 fdaf 	bl	800133e <HAL_QSPI_AutoPolling>
 80007e0:	3800      	subs	r0, #0
 80007e2:	bf18      	it	ne
 80007e4:	2001      	movne	r0, #1
}
 80007e6:	b015      	add	sp, #84	; 0x54
 80007e8:	f85d fb04 	ldr.w	pc, [sp], #4
    return MEMORY_ERROR;
 80007ec:	2001      	movs	r0, #1
 80007ee:	e7fa      	b.n	80007e6 <QSPI_WriteEnable.constprop.0+0x62>
 80007f0:	20000030 	.word	0x20000030

080007f4 <QSPI_Startup>:
{
 80007f4:	b5f0      	push	{r4, r5, r6, r7, lr}
  QSPIHandle.Instance = QUADSPI;
 80007f6:	4c7a      	ldr	r4, [pc, #488]	; (80009e0 <QSPI_Startup+0x1ec>)
{
 80007f8:	b09d      	sub	sp, #116	; 0x74
  QSPIHandle.Instance = QUADSPI;
 80007fa:	4b7a      	ldr	r3, [pc, #488]	; (80009e4 <QSPI_Startup+0x1f0>)
  if (HAL_QSPI_DeInit(&QSPIHandle) != HAL_OK)
 80007fc:	4620      	mov	r0, r4
  QSPIHandle.Instance = QUADSPI;
 80007fe:	6023      	str	r3, [r4, #0]
  if (HAL_QSPI_DeInit(&QSPIHandle) != HAL_OK)
 8000800:	f000 fc91 	bl	8001126 <HAL_QSPI_DeInit>
 8000804:	b118      	cbz	r0, 800080e <QSPI_Startup+0x1a>
    return MEMORY_ERROR;
 8000806:	2401      	movs	r4, #1
}
 8000808:	4620      	mov	r0, r4
 800080a:	b01d      	add	sp, #116	; 0x74
 800080c:	bdf0      	pop	{r4, r5, r6, r7, pc}
  QSPI_MspInit();
 800080e:	f7ff fe8b 	bl	8000528 <QSPI_MspInit>
  QSPIHandle.Init.FifoThreshold      = 1;
 8000812:	2603      	movs	r6, #3
 8000814:	2301      	movs	r3, #1
 8000816:	e9c4 6301 	strd	r6, r3, [r4, #4]
  QSPIHandle.Init.SampleShifting     = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
 800081a:	2310      	movs	r3, #16
 800081c:	60e3      	str	r3, [r4, #12]
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 800081e:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000822:	fa93 f3a3 	rbit	r3, r3
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
 8000826:	fab3 f383 	clz	r3, r3
  QSPIHandle.Init.ClockMode          = QSPI_CLOCK_MODE_0;
 800082a:	f44f 7540 	mov.w	r5, #768	; 0x300
 if (HAL_QSPI_Init(&QSPIHandle) != HAL_OK)
 800082e:	486c      	ldr	r0, [pc, #432]	; (80009e0 <QSPI_Startup+0x1ec>)
  QSPIHandle.Init.FlashSize          = POSITION_VAL(MT25TL01G_FLASH_SIZE) - 1;
 8000830:	3b01      	subs	r3, #1
 8000832:	6123      	str	r3, [r4, #16]
  QSPIHandle.Init.ClockMode          = QSPI_CLOCK_MODE_0;
 8000834:	2300      	movs	r3, #0
 8000836:	e9c4 5305 	strd	r5, r3, [r4, #20]
  QSPIHandle.Init.FlashID            = QSPI_FLASH_ID_1;
 800083a:	61e3      	str	r3, [r4, #28]
  QSPIHandle.Init.DualFlash          = QSPI_DUALFLASH_ENABLE;
 800083c:	2340      	movs	r3, #64	; 0x40
 800083e:	6223      	str	r3, [r4, #32]
 if (HAL_QSPI_Init(&QSPIHandle) != HAL_OK)
 8000840:	f000 fc22 	bl	8001088 <HAL_QSPI_Init>
 8000844:	2800      	cmp	r0, #0
 8000846:	d1de      	bne.n	8000806 <QSPI_Startup+0x12>
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 8000848:	f44f 7480 	mov.w	r4, #256	; 0x100
  s_command.Instruction       = MT25TL01G_RESET_ENABLE_CMD;
 800084c:	2766      	movs	r7, #102	; 0x66
  s_command.DataMode          = QSPI_DATA_NONE;
 800084e:	9009      	str	r0, [sp, #36]	; 0x24
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000850:	f241 3288 	movw	r2, #5000	; 0x1388
  s_command.DummyCycles       = 0;
 8000854:	9005      	str	r0, [sp, #20]
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000856:	4669      	mov	r1, sp
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 8000858:	900d      	str	r0, [sp, #52]	; 0x34
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 800085a:	9406      	str	r4, [sp, #24]
  s_command.Instruction       = MT25TL01G_RESET_ENABLE_CMD;
 800085c:	9700      	str	r7, [sp, #0]
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 800085e:	e9cd 0007 	strd	r0, r0, [sp, #28]
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
 8000862:	e9cd 000b 	strd	r0, r0, [sp, #44]	; 0x2c
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000866:	485e      	ldr	r0, [pc, #376]	; (80009e0 <QSPI_Startup+0x1ec>)
 8000868:	f000 fc6e 	bl	8001148 <HAL_QSPI_Command>
 800086c:	2800      	cmp	r0, #0
 800086e:	d1ca      	bne.n	8000806 <QSPI_Startup+0x12>
  s_command.Instruction = MT25TL01G_RESET_MEMORY_CMD;
 8000870:	2699      	movs	r6, #153	; 0x99
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000872:	f241 3288 	movw	r2, #5000	; 0x1388
 8000876:	4669      	mov	r1, sp
 8000878:	4859      	ldr	r0, [pc, #356]	; (80009e0 <QSPI_Startup+0x1ec>)
  s_command.Instruction = MT25TL01G_RESET_MEMORY_CMD;
 800087a:	9600      	str	r6, [sp, #0]
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800087c:	f000 fc64 	bl	8001148 <HAL_QSPI_Command>
 8000880:	2800      	cmp	r0, #0
 8000882:	d1c0      	bne.n	8000806 <QSPI_Startup+0x12>
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000884:	f241 3288 	movw	r2, #5000	; 0x1388
 8000888:	4669      	mov	r1, sp
 800088a:	4855      	ldr	r0, [pc, #340]	; (80009e0 <QSPI_Startup+0x1ec>)
  s_command.InstructionMode   = QSPI_INSTRUCTION_4_LINES;
 800088c:	9506      	str	r5, [sp, #24]
  s_command.Instruction       = MT25TL01G_RESET_ENABLE_CMD;
 800088e:	9700      	str	r7, [sp, #0]
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000890:	f000 fc5a 	bl	8001148 <HAL_QSPI_Command>
 8000894:	2800      	cmp	r0, #0
 8000896:	d1b6      	bne.n	8000806 <QSPI_Startup+0x12>
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000898:	f241 3288 	movw	r2, #5000	; 0x1388
 800089c:	4669      	mov	r1, sp
 800089e:	4850      	ldr	r0, [pc, #320]	; (80009e0 <QSPI_Startup+0x1ec>)
  s_command.Instruction = MT25TL01G_RESET_MEMORY_CMD;
 80008a0:	9600      	str	r6, [sp, #0]
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80008a2:	f000 fc51 	bl	8001148 <HAL_QSPI_Command>
 80008a6:	2800      	cmp	r0, #0
 80008a8:	d1ad      	bne.n	8000806 <QSPI_Startup+0x12>
static uint8_t QSPI_EnterQPI(QSPI_HandleTypeDef *hqspi)
{
  QSPI_CommandTypeDef s_command;

  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
  s_command.Instruction       = MT25TL01G_ENTER_QUAD_CMD;
 80008aa:	2335      	movs	r3, #53	; 0x35
  s_command.AddressMode       = QSPI_ADDRESS_NONE;
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
  s_command.DataMode          = QSPI_DATA_NONE;
 80008ac:	9017      	str	r0, [sp, #92]	; 0x5c
  s_command.DummyCycles       = 0;
 80008ae:	9013      	str	r0, [sp, #76]	; 0x4c
  s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;

  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80008b0:	f241 3288 	movw	r2, #5000	; 0x1388
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 80008b4:	901b      	str	r0, [sp, #108]	; 0x6c
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80008b6:	a90e      	add	r1, sp, #56	; 0x38
  s_command.InstructionMode   = QSPI_INSTRUCTION_1_LINE;
 80008b8:	9414      	str	r4, [sp, #80]	; 0x50
  s_command.Instruction       = MT25TL01G_ENTER_QUAD_CMD;
 80008ba:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 80008bc:	e9cd 0015 	strd	r0, r0, [sp, #84]	; 0x54
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
 80008c0:	e9cd 0019 	strd	r0, r0, [sp, #100]	; 0x64
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 80008c4:	4846      	ldr	r0, [pc, #280]	; (80009e0 <QSPI_Startup+0x1ec>)
 80008c6:	f000 fc3f 	bl	8001148 <HAL_QSPI_Command>
 80008ca:	2800      	cmp	r0, #0
 80008cc:	d19b      	bne.n	8000806 <QSPI_Startup+0x12>
  if (QSPI_AutoPollingMemReady(hqspi, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != MEMORY_OK)
 80008ce:	f7ff ff2d 	bl	800072c <QSPI_AutoPollingMemReady.constprop.0>
 80008d2:	2800      	cmp	r0, #0
 80008d4:	d197      	bne.n	8000806 <QSPI_Startup+0x12>
  s_command.Instruction       = MT25TL01G_ENTER_4_BYTE_ADDR_MODE_CMD;
 80008d6:	23b7      	movs	r3, #183	; 0xb7
  s_command.InstructionMode   = QSPI_INSTRUCTION_4_LINES;
 80008d8:	9514      	str	r5, [sp, #80]	; 0x50
  s_command.DataMode          = QSPI_DATA_NONE;
 80008da:	9017      	str	r0, [sp, #92]	; 0x5c
  s_command.Instruction       = MT25TL01G_ENTER_4_BYTE_ADDR_MODE_CMD;
 80008dc:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.DummyCycles       = 0;
 80008de:	9013      	str	r0, [sp, #76]	; 0x4c
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 80008e0:	901b      	str	r0, [sp, #108]	; 0x6c
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 80008e2:	e9cd 0015 	strd	r0, r0, [sp, #84]	; 0x54
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_ANALOG_DELAY;
 80008e6:	e9cd 0019 	strd	r0, r0, [sp, #100]	; 0x64
  if (QSPI_WriteEnable(hqspi) != MEMORY_OK)
 80008ea:	f7ff ff4b 	bl	8000784 <QSPI_WriteEnable.constprop.0>
 80008ee:	2800      	cmp	r0, #0
 80008f0:	d189      	bne.n	8000806 <QSPI_Startup+0x12>
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != MEMORY_OK)
 80008f2:	f241 3288 	movw	r2, #5000	; 0x1388
 80008f6:	a90e      	add	r1, sp, #56	; 0x38
 80008f8:	4839      	ldr	r0, [pc, #228]	; (80009e0 <QSPI_Startup+0x1ec>)
 80008fa:	f000 fc25 	bl	8001148 <HAL_QSPI_Command>
 80008fe:	2800      	cmp	r0, #0
 8000900:	d181      	bne.n	8000806 <QSPI_Startup+0x12>
  if (QSPI_AutoPollingMemReady(hqspi, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != MEMORY_OK)
 8000902:	f7ff ff13 	bl	800072c <QSPI_AutoPollingMemReady.constprop.0>
 8000906:	2800      	cmp	r0, #0
 8000908:	f47f af7d 	bne.w	8000806 <QSPI_Startup+0x12>
  s_command.Instruction       = MT25TL01G_READ_VOL_CFG_REG_CMD;
 800090c:	2285      	movs	r2, #133	; 0x85
  uint16_t reg=0;
 800090e:	2300      	movs	r3, #0
  s_command.InstructionMode   = QSPI_INSTRUCTION_4_LINES;
 8000910:	f44f 7640 	mov.w	r6, #768	; 0x300
  s_command.DataMode          = QSPI_DATA_4_LINES;
 8000914:	f04f 7540 	mov.w	r5, #50331648	; 0x3000000
  s_command.Instruction       = MT25TL01G_READ_VOL_CFG_REG_CMD;
 8000918:	920e      	str	r2, [sp, #56]	; 0x38
  s_command.NbData            = 2;
 800091a:	2202      	movs	r2, #2
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800091c:	a90e      	add	r1, sp, #56	; 0x38
 800091e:	4830      	ldr	r0, [pc, #192]	; (80009e0 <QSPI_Startup+0x1ec>)
  uint16_t reg=0;
 8000920:	f8ad 3000 	strh.w	r3, [sp]
  s_command.InstructionMode   = QSPI_INSTRUCTION_4_LINES;
 8000924:	9614      	str	r6, [sp, #80]	; 0x50
  s_command.DataMode          = QSPI_DATA_4_LINES;
 8000926:	9517      	str	r5, [sp, #92]	; 0x5c
  s_command.DummyCycles       = 0;
 8000928:	9313      	str	r3, [sp, #76]	; 0x4c
  s_command.DdrMode           = QSPI_DDR_MODE_DISABLE;
 800092a:	e9cd 2318 	strd	r2, r3, [sp, #96]	; 0x60
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800092e:	f241 3288 	movw	r2, #5000	; 0x1388
  s_command.AlternateByteMode = QSPI_ALTERNATE_BYTES_NONE;
 8000932:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 8000936:	e9cd 331a 	strd	r3, r3, [sp, #104]	; 0x68
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 800093a:	f000 fc05 	bl	8001148 <HAL_QSPI_Command>
 800093e:	2800      	cmp	r0, #0
 8000940:	f47f af61 	bne.w	8000806 <QSPI_Startup+0x12>
  if (HAL_QSPI_Receive(hqspi, (uint8_t *)(&reg), HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000944:	f241 3288 	movw	r2, #5000	; 0x1388
 8000948:	4669      	mov	r1, sp
 800094a:	4825      	ldr	r0, [pc, #148]	; (80009e0 <QSPI_Startup+0x1ec>)
 800094c:	f000 fc98 	bl	8001280 <HAL_QSPI_Receive>
 8000950:	2800      	cmp	r0, #0
 8000952:	f47f af58 	bne.w	8000806 <QSPI_Startup+0x12>
  if (QSPI_WriteEnable(hqspi) != MEMORY_OK)
 8000956:	f7ff ff15 	bl	8000784 <QSPI_WriteEnable.constprop.0>
 800095a:	4604      	mov	r4, r0
 800095c:	2800      	cmp	r0, #0
 800095e:	f47f af52 	bne.w	8000806 <QSPI_Startup+0x12>
  s_command.Instruction = MT25TL01G_WRITE_VOL_CFG_REG_CMD;
 8000962:	2381      	movs	r3, #129	; 0x81
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000964:	f241 3288 	movw	r2, #5000	; 0x1388
 8000968:	a90e      	add	r1, sp, #56	; 0x38
 800096a:	481d      	ldr	r0, [pc, #116]	; (80009e0 <QSPI_Startup+0x1ec>)
  s_command.Instruction = MT25TL01G_WRITE_VOL_CFG_REG_CMD;
 800096c:	930e      	str	r3, [sp, #56]	; 0x38
  MODIFY_REG(reg, 0xF0F0, ((MT25TL01G_DUMMY_CYCLES_READ_QUAD << 4) |
 800096e:	f8bd 3000 	ldrh.w	r3, [sp]
 8000972:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8000976:	051b      	lsls	r3, r3, #20
 8000978:	0d1b      	lsrs	r3, r3, #20
 800097a:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800097e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000982:	f8ad 3000 	strh.w	r3, [sp]
  if (HAL_QSPI_Command(hqspi, &s_command, HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000986:	f000 fbdf 	bl	8001148 <HAL_QSPI_Command>
 800098a:	2800      	cmp	r0, #0
 800098c:	f47f af3b 	bne.w	8000806 <QSPI_Startup+0x12>
  if (HAL_QSPI_Transmit(hqspi, (uint8_t *)(&reg), HAL_QPSI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
 8000990:	f241 3288 	movw	r2, #5000	; 0x1388
 8000994:	4669      	mov	r1, sp
 8000996:	4812      	ldr	r0, [pc, #72]	; (80009e0 <QSPI_Startup+0x1ec>)
 8000998:	f000 fc19 	bl	80011ce <HAL_QSPI_Transmit>
 800099c:	2800      	cmp	r0, #0
 800099e:	f47f af32 	bne.w	8000806 <QSPI_Startup+0x12>
  s_command.Instruction       = MT25TL01G_QUAD_INOUT_FAST_READ_DTR_CMD; /* DTR QUAD INPUT/OUTPUT FAST READ and 4-BYTE DTR FAST READ commands */
 80009a2:	23ed      	movs	r3, #237	; 0xed
  if (HAL_QSPI_MemoryMapped(&QSPIHandle, &s_command, &s_mem_mapped_cfg) != HAL_OK)
 80009a4:	466a      	mov	r2, sp
 80009a6:	a90e      	add	r1, sp, #56	; 0x38
 80009a8:	480d      	ldr	r0, [pc, #52]	; (80009e0 <QSPI_Startup+0x1ec>)
  s_command.Instruction       = MT25TL01G_QUAD_INOUT_FAST_READ_DTR_CMD; /* DTR QUAD INPUT/OUTPUT FAST READ and 4-BYTE DTR FAST READ commands */
 80009aa:	930e      	str	r3, [sp, #56]	; 0x38
  s_command.AddressMode       = QSPI_ADDRESS_4_LINES;
 80009ac:	f44f 6340 	mov.w	r3, #3072	; 0xc00
  s_command.SIOOMode          = QSPI_SIOO_INST_EVERY_CMD;
 80009b0:	941b      	str	r4, [sp, #108]	; 0x6c
  s_command.AddressMode       = QSPI_ADDRESS_4_LINES;
 80009b2:	9315      	str	r3, [sp, #84]	; 0x54
  s_command.AddressSize       = QSPI_ADDRESS_32_BITS;
 80009b4:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  s_command.InstructionMode   = QSPI_INSTRUCTION_4_LINES;
 80009b8:	9614      	str	r6, [sp, #80]	; 0x50
  s_command.AddressSize       = QSPI_ADDRESS_32_BITS;
 80009ba:	9311      	str	r3, [sp, #68]	; 0x44
  s_command.DummyCycles       = MT25TL01G_DUMMY_CYCLES_READ_QUAD_DTR - 1;
 80009bc:	2305      	movs	r3, #5
  s_command.DataMode          = QSPI_DATA_4_LINES;
 80009be:	e9cd 4516 	strd	r4, r5, [sp, #88]	; 0x58
  s_command.DummyCycles       = MT25TL01G_DUMMY_CYCLES_READ_QUAD_DTR - 1;
 80009c2:	9313      	str	r3, [sp, #76]	; 0x4c
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_HALF_CLK_DELAY;
 80009c4:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
 80009c8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  s_mem_mapped_cfg.TimeOutPeriod     = 0;
 80009cc:	e9cd 4400 	strd	r4, r4, [sp]
  s_command.DdrHoldHalfCycle  = QSPI_DDR_HHC_HALF_CLK_DELAY;
 80009d0:	e9cd 5319 	strd	r5, r3, [sp, #100]	; 0x64
  if (HAL_QSPI_MemoryMapped(&QSPIHandle, &s_command, &s_mem_mapped_cfg) != HAL_OK)
 80009d4:	f000 fd03 	bl	80013de <HAL_QSPI_MemoryMapped>
    return MEMORY_ERROR;
 80009d8:	2800      	cmp	r0, #0
 80009da:	bf18      	it	ne
 80009dc:	2401      	movne	r4, #1
 80009de:	e713      	b.n	8000808 <QSPI_Startup+0x14>
 80009e0:	20000030 	.word	0x20000030
 80009e4:	52005000 	.word	0x52005000

080009e8 <NMI_Handler>:
  * @param  None
  * @retval None
  */
void NMI_Handler(void)
{
}
 80009e8:	4770      	bx	lr

080009ea <HardFault_Handler>:
  * @retval None
  */
void HardFault_Handler(void)
{
  /* Go to infinite loop when Hard Fault exception occurs */
  while (1)
 80009ea:	e7fe      	b.n	80009ea <HardFault_Handler>

080009ec <MemManage_Handler>:
  * @retval None
  */
void MemManage_Handler(void)
{
  /* Go to infinite loop when Memory Manage exception occurs */
  while (1)
 80009ec:	e7fe      	b.n	80009ec <MemManage_Handler>

080009ee <BusFault_Handler>:
  * @retval None
  */
void BusFault_Handler(void)
{
  /* Go to infinite loop when Bus Fault exception occurs */
  while (1)
 80009ee:	e7fe      	b.n	80009ee <BusFault_Handler>

080009f0 <UsageFault_Handler>:
  * @retval None
  */
void UsageFault_Handler(void)
{
  /* Go to infinite loop when Usage Fault exception occurs */
  while (1)
 80009f0:	e7fe      	b.n	80009f0 <UsageFault_Handler>

080009f2 <SVC_Handler>:
 80009f2:	4770      	bx	lr

080009f4 <DebugMon_Handler>:
 80009f4:	4770      	bx	lr

080009f6 <PendSV_Handler>:
 80009f6:	4770      	bx	lr

080009f8 <SysTick_Handler>:
  * @param  None
  * @retval None
  */
void SysTick_Handler(void)
{
  HAL_IncTick();
 80009f8:	f000 b896 	b.w	8000b28 <HAL_IncTick>

080009fc <SystemInit>:
 __IO uint32_t tmpreg;
#endif /* DATA_IN_D2_SRAM */
    
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 80009fc:	491a      	ldr	r1, [pc, #104]	; (8000a68 <SystemInit+0x6c>)
  
  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;

  /* Reset HSEON, CSSON , CSION,RC48ON, CSIKERON PLL1ON, PLL2ON and PLL3ON bits */
  RCC->CR &= 0xEAF6ED7FU;
 80009fe:	481b      	ldr	r0, [pc, #108]	; (8000a6c <SystemInit+0x70>)
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8000a00:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8000a04:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
{
 8000a08:	b510      	push	{r4, lr}
    SCB->CPACR |= ((3UL << (10*2))|(3UL << (11*2)));  /* set CP10 and CP11 Full Access */
 8000a0a:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  RCC->CR |= RCC_CR_HSION;
 8000a0e:	4b18      	ldr	r3, [pc, #96]	; (8000a70 <SystemInit+0x74>)
 8000a10:	681a      	ldr	r2, [r3, #0]
 8000a12:	f042 0201 	orr.w	r2, r2, #1
 8000a16:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 8000a18:	2200      	movs	r2, #0
 8000a1a:	611a      	str	r2, [r3, #16]
  RCC->CR &= 0xEAF6ED7FU;
 8000a1c:	681c      	ldr	r4, [r3, #0]
 8000a1e:	4020      	ands	r0, r4
 8000a20:	6018      	str	r0, [r3, #0]

  /* Reset D1CFGR register */
  RCC->D1CFGR = 0x00000000;
 8000a22:	619a      	str	r2, [r3, #24]

  /* Reset D2CFGR register */
  RCC->D2CFGR = 0x00000000;
 8000a24:	61da      	str	r2, [r3, #28]
  
  /* Reset D3CFGR register */
  RCC->D3CFGR = 0x00000000;
 8000a26:	621a      	str	r2, [r3, #32]

  /* Reset PLLCKSELR register */
  RCC->PLLCKSELR = 0x00000000;
 8000a28:	629a      	str	r2, [r3, #40]	; 0x28

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00000000;
 8000a2a:	62da      	str	r2, [r3, #44]	; 0x2c
  /* Reset PLL1DIVR register */
  RCC->PLL1DIVR = 0x00000000;
 8000a2c:	631a      	str	r2, [r3, #48]	; 0x30
  /* Reset PLL1FRACR register */
  RCC->PLL1FRACR = 0x00000000;
 8000a2e:	635a      	str	r2, [r3, #52]	; 0x34

  /* Reset PLL2DIVR register */
  RCC->PLL2DIVR = 0x00000000;
 8000a30:	639a      	str	r2, [r3, #56]	; 0x38

  /* Reset PLL2FRACR register */
  
  RCC->PLL2FRACR = 0x00000000;
 8000a32:	63da      	str	r2, [r3, #60]	; 0x3c
  /* Reset PLL3DIVR register */
  RCC->PLL3DIVR = 0x00000000;
 8000a34:	641a      	str	r2, [r3, #64]	; 0x40

  /* Reset PLL3FRACR register */
  RCC->PLL3FRACR = 0x00000000;
 8000a36:	645a      	str	r2, [r3, #68]	; 0x44
  
  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 8000a38:	6818      	ldr	r0, [r3, #0]
 8000a3a:	f420 2080 	bic.w	r0, r0, #262144	; 0x40000
 8000a3e:	6018      	str	r0, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 8000a40:	661a      	str	r2, [r3, #96]	; 0x60

  /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
  if((DBGMCU->IDCODE & 0xFFFF0000U) < 0x20000000U)
 8000a42:	4b0c      	ldr	r3, [pc, #48]	; (8000a74 <SystemInit+0x78>)
 8000a44:	681b      	ldr	r3, [r3, #0]
 8000a46:	0c1b      	lsrs	r3, r3, #16
 8000a48:	041b      	lsls	r3, r3, #16
 8000a4a:	f1b3 5f00 	cmp.w	r3, #536870912	; 0x20000000
 8000a4e:	d203      	bcs.n	8000a58 <SystemInit+0x5c>
  {
    /* if stm32h7 revY*/
    /* Change  the switch matrix read issuing capability to 1 for the AXI SRAM target (Target 7) */
    *((__IO uint32_t*)0x51008108) = 0x00000001U;
 8000a50:	4b09      	ldr	r3, [pc, #36]	; (8000a78 <SystemInit+0x7c>)
 8000a52:	2201      	movs	r2, #1
 8000a54:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
/*
   * Disable the FMC bank1 (enabled after reset).
   * This, prevents CPU speculation access on this bank which blocks the use of FMC during
   * 24us. During this time the others FMC master (such as LTDC) cannot use it!
   */
  FMC_Bank1_R->BTCR[0] = 0x000030D2;
 8000a58:	4b08      	ldr	r3, [pc, #32]	; (8000a7c <SystemInit+0x80>)
 8000a5a:	f243 02d2 	movw	r2, #12498	; 0x30d2
 8000a5e:	601a      	str	r2, [r3, #0]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = D1_AXISRAM_BASE  | VECT_TAB_OFFSET;       /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BANK1_BASE | VECT_TAB_OFFSET;       /* Vector Table Relocation in Internal FLASH */
 8000a60:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8000a64:	608b      	str	r3, [r1, #8]
#endif  


}
 8000a66:	bd10      	pop	{r4, pc}
 8000a68:	e000ed00 	.word	0xe000ed00
 8000a6c:	eaf6ed7f 	.word	0xeaf6ed7f
 8000a70:	58024400 	.word	0x58024400
 8000a74:	5c001000 	.word	0x5c001000
 8000a78:	51008000 	.word	0x51008000
 8000a7c:	52004000 	.word	0x52004000

08000a80 <HAL_MspInit>:
__weak void HAL_MspInit(void)
{
  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_MspInit could be implemented in the user file
   */
}
 8000a80:	4770      	bx	lr
	...

08000a84 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority: Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000a84:	b570      	push	{r4, r5, r6, lr}
  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that don't take the value zero)*/
  if((uint32_t)uwTickFreq == 0UL)
 8000a86:	4e0f      	ldr	r6, [pc, #60]	; (8000ac4 <HAL_InitTick+0x40>)
{
 8000a88:	4605      	mov	r5, r0
  if((uint32_t)uwTickFreq == 0UL)
 8000a8a:	7830      	ldrb	r0, [r6, #0]
 8000a8c:	b908      	cbnz	r0, 8000a92 <HAL_InitTick+0xe>
  {
    return HAL_ERROR;
 8000a8e:	2001      	movs	r0, #1
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
}
 8000a90:	bd70      	pop	{r4, r5, r6, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000UL / (uint32_t)uwTickFreq)) > 0U)
 8000a92:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000a96:	4a0c      	ldr	r2, [pc, #48]	; (8000ac8 <HAL_InitTick+0x44>)
 8000a98:	fbb3 f3f0 	udiv	r3, r3, r0
 8000a9c:	6810      	ldr	r0, [r2, #0]
 8000a9e:	fbb0 f0f3 	udiv	r0, r0, r3
 8000aa2:	f000 f8ab 	bl	8000bfc <HAL_SYSTICK_Config>
 8000aa6:	4604      	mov	r4, r0
 8000aa8:	2800      	cmp	r0, #0
 8000aaa:	d1f0      	bne.n	8000a8e <HAL_InitTick+0xa>
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8000aac:	2d0f      	cmp	r5, #15
 8000aae:	d8ee      	bhi.n	8000a8e <HAL_InitTick+0xa>
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8000ab0:	4602      	mov	r2, r0
 8000ab2:	4629      	mov	r1, r5
 8000ab4:	f04f 30ff 	mov.w	r0, #4294967295
 8000ab8:	f000 f860 	bl	8000b7c <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8000abc:	4620      	mov	r0, r4
 8000abe:	6075      	str	r5, [r6, #4]
  return HAL_OK;
 8000ac0:	e7e6      	b.n	8000a90 <HAL_InitTick+0xc>
 8000ac2:	bf00      	nop
 8000ac4:	20000008 	.word	0x20000008
 8000ac8:	20000000 	.word	0x20000000

08000acc <HAL_Init>:
{
 8000acc:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000ace:	2003      	movs	r0, #3
 8000ad0:	f000 f842 	bl	8000b58 <HAL_NVIC_SetPriorityGrouping>
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8000ad4:	f000 ff56 	bl	8001984 <HAL_RCC_GetSysClockFreq>
 8000ad8:	490f      	ldr	r1, [pc, #60]	; (8000b18 <HAL_Init+0x4c>)
 8000ada:	4a10      	ldr	r2, [pc, #64]	; (8000b1c <HAL_Init+0x50>)
 8000adc:	698b      	ldr	r3, [r1, #24]
 8000ade:	f3c3 2303 	ubfx	r3, r3, #8, #4
 8000ae2:	5cd3      	ldrb	r3, [r2, r3]
 8000ae4:	f003 031f 	and.w	r3, r3, #31
 8000ae8:	40d8      	lsrs	r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8000aea:	698b      	ldr	r3, [r1, #24]
 8000aec:	f003 030f 	and.w	r3, r3, #15
 8000af0:	5cd3      	ldrb	r3, [r2, r3]
 8000af2:	4a0b      	ldr	r2, [pc, #44]	; (8000b20 <HAL_Init+0x54>)
 8000af4:	f003 031f 	and.w	r3, r3, #31
 8000af8:	fa20 f303 	lsr.w	r3, r0, r3
 8000afc:	6013      	str	r3, [r2, #0]
  SystemCoreClock = common_system_clock;
 8000afe:	4b09      	ldr	r3, [pc, #36]	; (8000b24 <HAL_Init+0x58>)
 8000b00:	6018      	str	r0, [r3, #0]
  if(HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 8000b02:	200f      	movs	r0, #15
 8000b04:	f7ff ffbe 	bl	8000a84 <HAL_InitTick>
 8000b08:	4604      	mov	r4, r0
 8000b0a:	b918      	cbnz	r0, 8000b14 <HAL_Init+0x48>
  HAL_MspInit();
 8000b0c:	f7ff ffb8 	bl	8000a80 <HAL_MspInit>
}
 8000b10:	4620      	mov	r0, r4
 8000b12:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8000b14:	2401      	movs	r4, #1
 8000b16:	e7fb      	b.n	8000b10 <HAL_Init+0x44>
 8000b18:	58024400 	.word	0x58024400
 8000b1c:	08001d70 	.word	0x08001d70
 8000b20:	20000004 	.word	0x20000004
 8000b24:	20000000 	.word	0x20000000

08000b28 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += (uint32_t)uwTickFreq;
 8000b28:	4a03      	ldr	r2, [pc, #12]	; (8000b38 <HAL_IncTick+0x10>)
 8000b2a:	4b04      	ldr	r3, [pc, #16]	; (8000b3c <HAL_IncTick+0x14>)
 8000b2c:	6811      	ldr	r1, [r2, #0]
 8000b2e:	781b      	ldrb	r3, [r3, #0]
 8000b30:	440b      	add	r3, r1
 8000b32:	6013      	str	r3, [r2, #0]
}
 8000b34:	4770      	bx	lr
 8000b36:	bf00      	nop
 8000b38:	2000007c 	.word	0x2000007c
 8000b3c:	20000008 	.word	0x20000008

08000b40 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000b40:	4b01      	ldr	r3, [pc, #4]	; (8000b48 <HAL_GetTick+0x8>)
 8000b42:	6818      	ldr	r0, [r3, #0]
}
 8000b44:	4770      	bx	lr
 8000b46:	bf00      	nop
 8000b48:	2000007c 	.word	0x2000007c

08000b4c <HAL_GetREVID>:
  * @brief  Returns the device revision identifier.
  * @retval Device revision identifier
  */
uint32_t HAL_GetREVID(void)
{
   return((DBGMCU->IDCODE) >> 16);
 8000b4c:	4b01      	ldr	r3, [pc, #4]	; (8000b54 <HAL_GetREVID+0x8>)
 8000b4e:	6818      	ldr	r0, [r3, #0]
}
 8000b50:	0c00      	lsrs	r0, r0, #16
 8000b52:	4770      	bx	lr
 8000b54:	5c001000 	.word	0x5c001000

08000b58 <HAL_NVIC_SetPriorityGrouping>:
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000b58:	4907      	ldr	r1, [pc, #28]	; (8000b78 <HAL_NVIC_SetPriorityGrouping+0x20>)
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000b5a:	0203      	lsls	r3, r0, #8
  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000b5c:	68ca      	ldr	r2, [r1, #12]
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8000b5e:	f403 63e0 	and.w	r3, r3, #1792	; 0x700
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000b62:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8000b66:	0412      	lsls	r2, r2, #16
 8000b68:	0c12      	lsrs	r2, r2, #16
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8000b6a:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8000b6c:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8000b70:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
  SCB->AIRCR =  reg_value;
 8000b74:	60cb      	str	r3, [r1, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8000b76:	4770      	bx	lr
 8000b78:	e000ed00 	.word	0xe000ed00

08000b7c <HAL_NVIC_SetPriority>:
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8000b7c:	4b16      	ldr	r3, [pc, #88]	; (8000bd8 <HAL_NVIC_SetPriority+0x5c>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8000b7e:	b530      	push	{r4, r5, lr}
 8000b80:	68dc      	ldr	r4, [r3, #12]
 8000b82:	f3c4 2402 	ubfx	r4, r4, #8, #3
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000b86:	f1c4 0507 	rsb	r5, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000b8a:	1d23      	adds	r3, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8000b8c:	2d04      	cmp	r5, #4
 8000b8e:	bf28      	it	cs
 8000b90:	2504      	movcs	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000b92:	2b06      	cmp	r3, #6
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000b94:	f04f 33ff 	mov.w	r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8000b98:	bf8c      	ite	hi
 8000b9a:	3c03      	subhi	r4, #3
 8000b9c:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000b9e:	fa03 f505 	lsl.w	r5, r3, r5
  if ((int32_t)(IRQn) >= 0)
 8000ba2:	2800      	cmp	r0, #0
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000ba4:	fa03 f304 	lsl.w	r3, r3, r4
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000ba8:	ea21 0105 	bic.w	r1, r1, r5
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8000bac:	ea22 0203 	bic.w	r2, r2, r3
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8000bb0:	fa01 f104 	lsl.w	r1, r1, r4
 8000bb4:	ea41 0302 	orr.w	r3, r1, r2
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000bb8:	ea4f 1303 	mov.w	r3, r3, lsl #4
 8000bbc:	b2db      	uxtb	r3, r3
  if ((int32_t)(IRQn) >= 0)
 8000bbe:	db06      	blt.n	8000bce <HAL_NVIC_SetPriority+0x52>
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000bc0:	f100 4060 	add.w	r0, r0, #3758096384	; 0xe0000000
 8000bc4:	f500 4061 	add.w	r0, r0, #57600	; 0xe100
 8000bc8:	f880 3300 	strb.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8000bcc:	bd30      	pop	{r4, r5, pc}
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000bce:	f000 000f 	and.w	r0, r0, #15
 8000bd2:	4a02      	ldr	r2, [pc, #8]	; (8000bdc <HAL_NVIC_SetPriority+0x60>)
 8000bd4:	5413      	strb	r3, [r2, r0]
 8000bd6:	e7f9      	b.n	8000bcc <HAL_NVIC_SetPriority+0x50>
 8000bd8:	e000ed00 	.word	0xe000ed00
 8000bdc:	e000ed14 	.word	0xe000ed14

08000be0 <HAL_NVIC_EnableIRQ>:
  if ((int32_t)(IRQn) >= 0)
 8000be0:	2800      	cmp	r0, #0
 8000be2:	db08      	blt.n	8000bf6 <HAL_NVIC_EnableIRQ+0x16>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8000be4:	2301      	movs	r3, #1
 8000be6:	0942      	lsrs	r2, r0, #5
 8000be8:	f000 001f 	and.w	r0, r0, #31
 8000bec:	fa03 f000 	lsl.w	r0, r3, r0
 8000bf0:	4b01      	ldr	r3, [pc, #4]	; (8000bf8 <HAL_NVIC_EnableIRQ+0x18>)
 8000bf2:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
}
 8000bf6:	4770      	bx	lr
 8000bf8:	e000e100 	.word	0xe000e100

08000bfc <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8000bfc:	3801      	subs	r0, #1
 8000bfe:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 8000c02:	d20b      	bcs.n	8000c1c <HAL_SYSTICK_Config+0x20>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000c04:	f04f 23e0 	mov.w	r3, #3758153728	; 0xe000e000
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000c08:	4a05      	ldr	r2, [pc, #20]	; (8000c20 <HAL_SYSTICK_Config+0x24>)
 8000c0a:	21f0      	movs	r1, #240	; 0xf0
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8000c0c:	6158      	str	r0, [r3, #20]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000c0e:	2000      	movs	r0, #0
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000c10:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000c14:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8000c16:	6198      	str	r0, [r3, #24]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8000c18:	611a      	str	r2, [r3, #16]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8000c1a:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8000c1c:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8000c1e:	4770      	bx	lr
 8000c20:	e000ed00 	.word	0xe000ed00

08000c24 <HAL_MPU_Disable>:
  __ASM volatile ("dmb 0xF":::"memory");
 8000c24:	f3bf 8f5f 	dmb	sy
{
  /* Make sure outstanding transfers are done */
  __DMB();

  /* Disable fault exceptions */
  SCB->SHCSR &= ~SCB_SHCSR_MEMFAULTENA_Msk;
 8000c28:	4b04      	ldr	r3, [pc, #16]	; (8000c3c <HAL_MPU_Disable+0x18>)
 8000c2a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000c2c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8000c30:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable the MPU and clear the control register*/
  MPU->CTRL = 0;
 8000c32:	2200      	movs	r2, #0
 8000c34:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
}
 8000c38:	4770      	bx	lr
 8000c3a:	bf00      	nop
 8000c3c:	e000ed00 	.word	0xe000ed00

08000c40 <HAL_MPU_Enable>:
  * @retval None
  */
void HAL_MPU_Enable(uint32_t MPU_Control)
{
  /* Enable the MPU */
  MPU->CTRL = MPU_Control | MPU_CTRL_ENABLE_Msk;
 8000c40:	4b06      	ldr	r3, [pc, #24]	; (8000c5c <HAL_MPU_Enable+0x1c>)
 8000c42:	f040 0001 	orr.w	r0, r0, #1
 8000c46:	f8c3 0094 	str.w	r0, [r3, #148]	; 0x94

  /* Enable fault exceptions */
  SCB->SHCSR |= SCB_SHCSR_MEMFAULTENA_Msk;
 8000c4a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8000c4c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000c50:	625a      	str	r2, [r3, #36]	; 0x24
  __ASM volatile ("dsb 0xF":::"memory");
 8000c52:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8000c56:	f3bf 8f6f 	isb	sy

  /* Ensure MPU setting take effects */
  __DSB();
  __ISB();
}
 8000c5a:	4770      	bx	lr
 8000c5c:	e000ed00 	.word	0xe000ed00

08000c60 <HAL_MPU_ConfigRegion>:
  /* Check the parameters */
  assert_param(IS_MPU_REGION_NUMBER(MPU_Init->Number));
  assert_param(IS_MPU_REGION_ENABLE(MPU_Init->Enable));

  /* Set the Region number */
  MPU->RNR = MPU_Init->Number;
 8000c60:	7843      	ldrb	r3, [r0, #1]
 8000c62:	4a14      	ldr	r2, [pc, #80]	; (8000cb4 <HAL_MPU_ConfigRegion+0x54>)
{
 8000c64:	b510      	push	{r4, lr}
  MPU->RNR = MPU_Init->Number;
 8000c66:	f8c2 3098 	str.w	r3, [r2, #152]	; 0x98

  if ((MPU_Init->Enable) != 0UL)
 8000c6a:	7801      	ldrb	r1, [r0, #0]
 8000c6c:	b1e9      	cbz	r1, 8000caa <HAL_MPU_ConfigRegion+0x4a>
    assert_param(IS_MPU_ACCESS_CACHEABLE(MPU_Init->IsCacheable));
    assert_param(IS_MPU_ACCESS_BUFFERABLE(MPU_Init->IsBufferable));
    assert_param(IS_MPU_SUB_REGION_DISABLE(MPU_Init->SubRegionDisable));
    assert_param(IS_MPU_REGION_SIZE(MPU_Init->Size));

    MPU->RBAR = MPU_Init->BaseAddress;
 8000c6e:	6843      	ldr	r3, [r0, #4]
 8000c70:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8000c74:	7ac3      	ldrb	r3, [r0, #11]
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8000c76:	7b04      	ldrb	r4, [r0, #12]
                ((uint32_t)MPU_Init->AccessPermission        << MPU_RASR_AP_Pos)   |
 8000c78:	061b      	lsls	r3, r3, #24
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8000c7a:	ea43 7304 	orr.w	r3, r3, r4, lsl #28
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8000c7e:	430b      	orrs	r3, r1
                ((uint32_t)MPU_Init->TypeExtField            << MPU_RASR_TEX_Pos)  |
 8000c80:	7a81      	ldrb	r1, [r0, #10]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8000c82:	ea43 43c1 	orr.w	r3, r3, r1, lsl #19
                ((uint32_t)MPU_Init->IsShareable             << MPU_RASR_S_Pos)    |
 8000c86:	7b41      	ldrb	r1, [r0, #13]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8000c88:	ea43 4381 	orr.w	r3, r3, r1, lsl #18
                ((uint32_t)MPU_Init->IsCacheable             << MPU_RASR_C_Pos)    |
 8000c8c:	7b81      	ldrb	r1, [r0, #14]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8000c8e:	ea43 4341 	orr.w	r3, r3, r1, lsl #17
                ((uint32_t)MPU_Init->IsBufferable            << MPU_RASR_B_Pos)    |
 8000c92:	7bc1      	ldrb	r1, [r0, #15]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8000c94:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
                ((uint32_t)MPU_Init->SubRegionDisable        << MPU_RASR_SRD_Pos)  |
 8000c98:	7a41      	ldrb	r1, [r0, #9]
                ((uint32_t)MPU_Init->Size                    << MPU_RASR_SIZE_Pos) |
 8000c9a:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8000c9e:	7a01      	ldrb	r1, [r0, #8]
 8000ca0:	ea43 0341 	orr.w	r3, r3, r1, lsl #1
    MPU->RASR = ((uint32_t)MPU_Init->DisableExec             << MPU_RASR_XN_Pos)   |
 8000ca4:	f8c2 30a0 	str.w	r3, [r2, #160]	; 0xa0
  else
  {
    MPU->RBAR = 0x00;
    MPU->RASR = 0x00;
  }
}
 8000ca8:	bd10      	pop	{r4, pc}
    MPU->RBAR = 0x00;
 8000caa:	f8c2 109c 	str.w	r1, [r2, #156]	; 0x9c
    MPU->RASR = 0x00;
 8000cae:	f8c2 10a0 	str.w	r1, [r2, #160]	; 0xa0
}
 8000cb2:	e7f9      	b.n	8000ca8 <HAL_MPU_ConfigRegion+0x48>
 8000cb4:	e000ed00 	.word	0xe000ed00

08000cb8 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8000cb8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  uint32_t position = 0x00U;
 8000cbc:	2300      	movs	r3, #0
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000cbe:	f8df 91cc 	ldr.w	r9, [pc, #460]	; 8000e8c <HAL_GPIO_Init+0x1d4>
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
        SYSCFG->EXTICR[position >> 2U] = temp;

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
 8000cc2:	f04f 44b0 	mov.w	r4, #1476395008	; 0x58000000
  while (((GPIO_Init->Pin) >> position) != 0x00U)
 8000cc6:	680a      	ldr	r2, [r1, #0]
 8000cc8:	fa32 f503 	lsrs.w	r5, r2, r3
 8000ccc:	d102      	bne.n	8000cd4 <HAL_GPIO_Init+0x1c>
      }
    }

    position++;
  }
}
 8000cce:	b003      	add	sp, #12
 8000cd0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
 8000cd4:	f04f 0e01 	mov.w	lr, #1
 8000cd8:	fa0e fe03 	lsl.w	lr, lr, r3
    if (iocurrent != 0x00U)
 8000cdc:	ea1e 0202 	ands.w	r2, lr, r2
 8000ce0:	f000 80bd 	beq.w	8000e5e <HAL_GPIO_Init+0x1a6>
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8000ce4:	684e      	ldr	r6, [r1, #4]
 8000ce6:	ea4f 0843 	mov.w	r8, r3, lsl #1
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8000cea:	f04f 0c03 	mov.w	ip, #3
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8000cee:	f006 0503 	and.w	r5, r6, #3
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8000cf2:	fa0c fc08 	lsl.w	ip, ip, r8
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8000cf6:	1e6f      	subs	r7, r5, #1
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8000cf8:	ea6f 0c0c 	mvn.w	ip, ip
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
 8000cfc:	2f01      	cmp	r7, #1
 8000cfe:	d834      	bhi.n	8000d6a <HAL_GPIO_Init+0xb2>
        temp = GPIOx->OSPEEDR;
 8000d00:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2U));
 8000d02:	ea07 0a0c 	and.w	sl, r7, ip
        temp |= (GPIO_Init->Speed << (position * 2U));
 8000d06:	68cf      	ldr	r7, [r1, #12]
 8000d08:	fa07 f708 	lsl.w	r7, r7, r8
 8000d0c:	ea47 070a 	orr.w	r7, r7, sl
        GPIOx->OSPEEDR = temp;
 8000d10:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 8000d12:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8000d14:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
 8000d18:	f3c6 1700 	ubfx	r7, r6, #4, #1
 8000d1c:	409f      	lsls	r7, r3
 8000d1e:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->OTYPER = temp;
 8000d22:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 8000d24:	68c7      	ldr	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8000d26:	2d02      	cmp	r5, #2
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2U));
 8000d28:	ea07 0e0c 	and.w	lr, r7, ip
      temp |= ((GPIO_Init->Pull) << (position * 2U));
 8000d2c:	688f      	ldr	r7, [r1, #8]
 8000d2e:	fa07 f708 	lsl.w	r7, r7, r8
 8000d32:	ea47 070e 	orr.w	r7, r7, lr
      GPIOx->PUPDR = temp;
 8000d36:	60c7      	str	r7, [r0, #12]
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
 8000d38:	d119      	bne.n	8000d6e <HAL_GPIO_Init+0xb6>
        temp = GPIOx->AFR[position >> 3U];
 8000d3a:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8000d3e:	f003 0b07 	and.w	fp, r3, #7
 8000d42:	f04f 0e0f 	mov.w	lr, #15
 8000d46:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
 8000d4a:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
        temp = GPIOx->AFR[position >> 3U];
 8000d4e:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0xFU << ((position & 0x07U) * 4U));
 8000d52:	fa0e fe0b 	lsl.w	lr, lr, fp
 8000d56:	ea27 0e0e 	bic.w	lr, r7, lr
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * 4U));
 8000d5a:	690f      	ldr	r7, [r1, #16]
 8000d5c:	fa07 f70b 	lsl.w	r7, r7, fp
 8000d60:	ea47 070e 	orr.w	r7, r7, lr
        GPIOx->AFR[position >> 3U] = temp;
 8000d64:	f8ca 7020 	str.w	r7, [sl, #32]
 8000d68:	e001      	b.n	8000d6e <HAL_GPIO_Init+0xb6>
      if ((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG)
 8000d6a:	2d03      	cmp	r5, #3
 8000d6c:	d1da      	bne.n	8000d24 <HAL_GPIO_Init+0x6c>
      temp = GPIOx->MODER;
 8000d6e:	6807      	ldr	r7, [r0, #0]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000d70:	fa05 f508 	lsl.w	r5, r5, r8
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8000d74:	f416 3f40 	tst.w	r6, #196608	; 0x30000
      temp &= ~(GPIO_MODER_MODE0 << (position * 2U));
 8000d78:	ea07 070c 	and.w	r7, r7, ip
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2U));
 8000d7c:	ea47 0705 	orr.w	r7, r7, r5
      GPIOx->MODER = temp;
 8000d80:	6007      	str	r7, [r0, #0]
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
 8000d82:	d06c      	beq.n	8000e5e <HAL_GPIO_Init+0x1a6>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000d84:	f8d9 50f4 	ldr.w	r5, [r9, #244]	; 0xf4
 8000d88:	f023 0703 	bic.w	r7, r3, #3
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8000d8c:	f003 0c03 	and.w	ip, r3, #3
 8000d90:	f04f 0e0f 	mov.w	lr, #15
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000d94:	f045 0502 	orr.w	r5, r5, #2
 8000d98:	f107 47b0 	add.w	r7, r7, #1476395008	; 0x58000000
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8000d9c:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000da0:	f8c9 50f4 	str.w	r5, [r9, #244]	; 0xf4
 8000da4:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 8000da8:	f8d9 50f4 	ldr.w	r5, [r9, #244]	; 0xf4
 8000dac:	f005 0502 	and.w	r5, r5, #2
 8000db0:	9501      	str	r5, [sp, #4]
 8000db2:	9d01      	ldr	r5, [sp, #4]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8000db4:	fa0e f50c 	lsl.w	r5, lr, ip
        temp = SYSCFG->EXTICR[position >> 2U];
 8000db8:	f8d7 8008 	ldr.w	r8, [r7, #8]
        temp &= ~(0x0FUL << (4U * (position & 0x03U)));
 8000dbc:	ea28 0e05 	bic.w	lr, r8, r5
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8000dc0:	4d31      	ldr	r5, [pc, #196]	; (8000e88 <HAL_GPIO_Init+0x1d0>)
 8000dc2:	42a8      	cmp	r0, r5
 8000dc4:	d04d      	beq.n	8000e62 <HAL_GPIO_Init+0x1aa>
 8000dc6:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000dca:	42a8      	cmp	r0, r5
 8000dcc:	d04b      	beq.n	8000e66 <HAL_GPIO_Init+0x1ae>
 8000dce:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000dd2:	42a8      	cmp	r0, r5
 8000dd4:	d049      	beq.n	8000e6a <HAL_GPIO_Init+0x1b2>
 8000dd6:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000dda:	42a8      	cmp	r0, r5
 8000ddc:	d047      	beq.n	8000e6e <HAL_GPIO_Init+0x1b6>
 8000dde:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000de2:	42a8      	cmp	r0, r5
 8000de4:	d045      	beq.n	8000e72 <HAL_GPIO_Init+0x1ba>
 8000de6:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000dea:	42a8      	cmp	r0, r5
 8000dec:	d043      	beq.n	8000e76 <HAL_GPIO_Init+0x1be>
 8000dee:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000df2:	42a8      	cmp	r0, r5
 8000df4:	d041      	beq.n	8000e7a <HAL_GPIO_Init+0x1c2>
 8000df6:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000dfa:	42a8      	cmp	r0, r5
 8000dfc:	d03f      	beq.n	8000e7e <HAL_GPIO_Init+0x1c6>
 8000dfe:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000e02:	42a8      	cmp	r0, r5
 8000e04:	d03d      	beq.n	8000e82 <HAL_GPIO_Init+0x1ca>
 8000e06:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8000e0a:	42a8      	cmp	r0, r5
 8000e0c:	bf0c      	ite	eq
 8000e0e:	2509      	moveq	r5, #9
 8000e10:	250a      	movne	r5, #10
 8000e12:	fa05 f50c 	lsl.w	r5, r5, ip
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
 8000e16:	f416 1f80 	tst.w	r6, #1048576	; 0x100000
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8000e1a:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2U] = temp;
 8000e1e:	60bd      	str	r5, [r7, #8]
        temp &= ~(iocurrent);
 8000e20:	ea6f 0702 	mvn.w	r7, r2
        temp = EXTI->RTSR1;
 8000e24:	6825      	ldr	r5, [r4, #0]
        temp &= ~(iocurrent);
 8000e26:	bf0c      	ite	eq
 8000e28:	403d      	andeq	r5, r7
          temp |= iocurrent;
 8000e2a:	4315      	orrne	r5, r2
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
 8000e2c:	f416 1f00 	tst.w	r6, #2097152	; 0x200000
        EXTI->RTSR1 = temp;
 8000e30:	6025      	str	r5, [r4, #0]
        temp = EXTI->FTSR1;
 8000e32:	6865      	ldr	r5, [r4, #4]
        temp &= ~(iocurrent);
 8000e34:	bf0c      	ite	eq
 8000e36:	403d      	andeq	r5, r7
          temp |= iocurrent;
 8000e38:	4315      	orrne	r5, r2
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
 8000e3a:	f416 3f00 	tst.w	r6, #131072	; 0x20000
        EXTI->FTSR1 = temp;
 8000e3e:	6065      	str	r5, [r4, #4]
        temp = EXTI_CurrentCPU->EMR1;
 8000e40:	f8d4 5084 	ldr.w	r5, [r4, #132]	; 0x84
        temp &= ~(iocurrent);
 8000e44:	bf0c      	ite	eq
 8000e46:	403d      	andeq	r5, r7
          temp |= iocurrent;
 8000e48:	4315      	orrne	r5, r2
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
 8000e4a:	03f6      	lsls	r6, r6, #15
        EXTI_CurrentCPU->EMR1 = temp;
 8000e4c:	f8c4 5084 	str.w	r5, [r4, #132]	; 0x84
        temp = EXTI_CurrentCPU->IMR1;
 8000e50:	f8d4 5080 	ldr.w	r5, [r4, #128]	; 0x80
        temp &= ~(iocurrent);
 8000e54:	bf54      	ite	pl
 8000e56:	403d      	andpl	r5, r7
          temp |= iocurrent;
 8000e58:	4315      	orrmi	r5, r2
        EXTI_CurrentCPU->IMR1 = temp;
 8000e5a:	f8c4 5080 	str.w	r5, [r4, #128]	; 0x80
    position++;
 8000e5e:	3301      	adds	r3, #1
 8000e60:	e731      	b.n	8000cc6 <HAL_GPIO_Init+0xe>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4U * (position & 0x03U)));
 8000e62:	2500      	movs	r5, #0
 8000e64:	e7d5      	b.n	8000e12 <HAL_GPIO_Init+0x15a>
 8000e66:	2501      	movs	r5, #1
 8000e68:	e7d3      	b.n	8000e12 <HAL_GPIO_Init+0x15a>
 8000e6a:	2502      	movs	r5, #2
 8000e6c:	e7d1      	b.n	8000e12 <HAL_GPIO_Init+0x15a>
 8000e6e:	2503      	movs	r5, #3
 8000e70:	e7cf      	b.n	8000e12 <HAL_GPIO_Init+0x15a>
 8000e72:	2504      	movs	r5, #4
 8000e74:	e7cd      	b.n	8000e12 <HAL_GPIO_Init+0x15a>
 8000e76:	2505      	movs	r5, #5
 8000e78:	e7cb      	b.n	8000e12 <HAL_GPIO_Init+0x15a>
 8000e7a:	2506      	movs	r5, #6
 8000e7c:	e7c9      	b.n	8000e12 <HAL_GPIO_Init+0x15a>
 8000e7e:	2507      	movs	r5, #7
 8000e80:	e7c7      	b.n	8000e12 <HAL_GPIO_Init+0x15a>
 8000e82:	2508      	movs	r5, #8
 8000e84:	e7c5      	b.n	8000e12 <HAL_GPIO_Init+0x15a>
 8000e86:	bf00      	nop
 8000e88:	58020000 	.word	0x58020000
 8000e8c:	58024400 	.word	0x58024400

08000e90 <HAL_PWREx_ConfigSupply>:
  *         PWR_SMPS_2V5_SUPPLIES_EXT are used only for lines that supports SMPS
  *         regulator.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_PWREx_ConfigSupply (uint32_t SupplySource)
{
 8000e90:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param (IS_PWR_SUPPLY (SupplySource));

  /* Check if supply source was configured */
#if defined (PWR_FLAG_SCUEN)
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 8000e92:	4c10      	ldr	r4, [pc, #64]	; (8000ed4 <HAL_PWREx_ConfigSupply+0x44>)
 8000e94:	68e3      	ldr	r3, [r4, #12]
 8000e96:	f013 0f04 	tst.w	r3, #4
#else
  if ((PWR->CR3 & (PWR_CR3_SMPSEN | PWR_CR3_LDOEN | PWR_CR3_BYPASS)) != (PWR_CR3_SMPSEN | PWR_CR3_LDOEN))
#endif /* defined (PWR_FLAG_SCUEN) */
  {
    /* Check supply configuration */
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 8000e9a:	68e3      	ldr	r3, [r4, #12]
  if (__HAL_PWR_GET_FLAG (PWR_FLAG_SCUEN) == 0U)
 8000e9c:	d105      	bne.n	8000eaa <HAL_PWREx_ConfigSupply+0x1a>
    if ((PWR->CR3 & PWR_SUPPLY_CONFIG_MASK) != SupplySource)
 8000e9e:	f003 0307 	and.w	r3, r3, #7
    {
      /* Supply configuration update locked, can't apply a new supply config */
      return HAL_ERROR;
 8000ea2:	1a18      	subs	r0, r3, r0
 8000ea4:	bf18      	it	ne
 8000ea6:	2001      	movne	r0, #1
    }
  }
#endif /* defined (SMPS) */

  return HAL_OK;
}
 8000ea8:	bd38      	pop	{r3, r4, r5, pc}
  MODIFY_REG (PWR->CR3, PWR_SUPPLY_CONFIG_MASK, SupplySource);
 8000eaa:	f023 0307 	bic.w	r3, r3, #7
 8000eae:	4318      	orrs	r0, r3
 8000eb0:	60e0      	str	r0, [r4, #12]
  tickstart = HAL_GetTick ();
 8000eb2:	f7ff fe45 	bl	8000b40 <HAL_GetTick>
 8000eb6:	4605      	mov	r5, r0
  while (__HAL_PWR_GET_FLAG (PWR_FLAG_ACTVOSRDY) == 0U)
 8000eb8:	6863      	ldr	r3, [r4, #4]
 8000eba:	049b      	lsls	r3, r3, #18
 8000ebc:	d501      	bpl.n	8000ec2 <HAL_PWREx_ConfigSupply+0x32>
  return HAL_OK;
 8000ebe:	2000      	movs	r0, #0
 8000ec0:	e7f2      	b.n	8000ea8 <HAL_PWREx_ConfigSupply+0x18>
    if ((HAL_GetTick () - tickstart) > PWR_FLAG_SETTING_DELAY)
 8000ec2:	f7ff fe3d 	bl	8000b40 <HAL_GetTick>
 8000ec6:	1b40      	subs	r0, r0, r5
 8000ec8:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8000ecc:	d9f4      	bls.n	8000eb8 <HAL_PWREx_ConfigSupply+0x28>
      return HAL_ERROR;
 8000ece:	2001      	movs	r0, #1
 8000ed0:	e7ea      	b.n	8000ea8 <HAL_PWREx_ConfigSupply+0x18>
 8000ed2:	bf00      	nop
 8000ed4:	58024800 	.word	0x58024800

08000ed8 <QSPI_Config>:
  *            @arg QSPI_FUNCTIONAL_MODE_AUTO_POLLING: Automatic polling mode
  *            @arg QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED: Memory-mapped mode
  * @retval None
  */
static void QSPI_Config(QSPI_HandleTypeDef *hqspi, QSPI_CommandTypeDef *cmd, uint32_t FunctionalMode)
{
 8000ed8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  assert_param(IS_QSPI_FUNCTIONAL_MODE(FunctionalMode));

  if ((cmd->DataMode != QSPI_DATA_NONE) && (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED))
 8000edc:	6a4e      	ldr	r6, [r1, #36]	; 0x24
 8000ede:	b136      	cbz	r6, 8000eee <QSPI_Config+0x16>
 8000ee0:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
 8000ee4:	d003      	beq.n	8000eee <QSPI_Config+0x16>
  {
    /* Configure QSPI: DLR register with the number of data to read or write */
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
 8000ee6:	6a8b      	ldr	r3, [r1, #40]	; 0x28
 8000ee8:	6804      	ldr	r4, [r0, #0]
 8000eea:	3b01      	subs	r3, #1
 8000eec:	6123      	str	r3, [r4, #16]
  }

  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
 8000eee:	f8d1 9018 	ldr.w	r9, [r1, #24]
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
    {
      /* Configure QSPI: ABR register with alternate bytes value */
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);

      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8000ef2:	e9d1 7507 	ldrd	r7, r5, [r1, #28]
  if (cmd->InstructionMode != QSPI_INSTRUCTION_NONE)
 8000ef6:	f1b9 0f00 	cmp.w	r9, #0
 8000efa:	d04f      	beq.n	8000f9c <QSPI_Config+0xc4>
      {
        /*---- Command with instruction, address and alternate bytes ----*/
        /* Configure QSPI: CCR register with all communications parameters */
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000efc:	694b      	ldr	r3, [r1, #20]
 8000efe:	ea46 0909 	orr.w	r9, r6, r9
    WRITE_REG(hqspi->Instance->DLR, (cmd->NbData - 1U));
 8000f02:	6800      	ldr	r0, [r0, #0]
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000f04:	f8d1 a000 	ldr.w	sl, [r1]
 8000f08:	ea4f 4c83 	mov.w	ip, r3, lsl #18
 8000f0c:	f8d1 e034 	ldr.w	lr, [r1, #52]	; 0x34
 8000f10:	ea49 0902 	orr.w	r9, r9, r2
 8000f14:	e9d1 480b 	ldrd	r4, r8, [r1, #44]	; 0x2c
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
 8000f18:	b335      	cbz	r5, 8000f68 <QSPI_Config+0x90>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
 8000f1a:	688b      	ldr	r3, [r1, #8]
 8000f1c:	ea49 0505 	orr.w	r5, r9, r5
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000f20:	690e      	ldr	r6, [r1, #16]
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
 8000f22:	61c3      	str	r3, [r0, #28]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8000f24:	b19f      	cbz	r7, 8000f4e <QSPI_Config+0x76>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000f26:	ea4a 0307 	orr.w	r3, sl, r7
 8000f2a:	4323      	orrs	r3, r4
 8000f2c:	68cc      	ldr	r4, [r1, #12]
 8000f2e:	ea43 0308 	orr.w	r3, r3, r8
 8000f32:	ea43 030e 	orr.w	r3, r3, lr
 8000f36:	4333      	orrs	r3, r6
 8000f38:	4323      	orrs	r3, r4
 8000f3a:	ea43 030c 	orr.w	r3, r3, ip
 8000f3e:	432b      	orrs	r3, r5
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
                                         cmd->DataMode | (cmd->DummyCycles << QUADSPI_CCR_DCYC_Pos) |
                                         cmd->AlternateByteMode | cmd->AddressSize |
                                         cmd->AddressMode | cmd->InstructionMode | FunctionalMode));

        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 8000f40:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000f44:	6143      	str	r3, [r0, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 8000f46:	d00d      	beq.n	8000f64 <QSPI_Config+0x8c>
        {
          /* Configure QSPI: AR register with address value */
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
 8000f48:	684b      	ldr	r3, [r1, #4]
 8000f4a:	6183      	str	r3, [r0, #24]
 8000f4c:	e00a      	b.n	8000f64 <QSPI_Config+0x8c>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000f4e:	ea4a 0304 	orr.w	r3, sl, r4
 8000f52:	ea43 0308 	orr.w	r3, r3, r8
 8000f56:	ea43 030e 	orr.w	r3, r3, lr
 8000f5a:	4333      	orrs	r3, r6
 8000f5c:	ea43 030c 	orr.w	r3, r3, ip
 8000f60:	432b      	orrs	r3, r5
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000f62:	6143      	str	r3, [r0, #20]
                                           cmd->InstructionMode | FunctionalMode));
        }
      }
    }
  }
}
 8000f64:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8000f68:	b16f      	cbz	r7, 8000f86 <QSPI_Config+0xae>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000f6a:	ea4a 0307 	orr.w	r3, sl, r7
 8000f6e:	4323      	orrs	r3, r4
 8000f70:	68cc      	ldr	r4, [r1, #12]
 8000f72:	ea43 0308 	orr.w	r3, r3, r8
 8000f76:	ea43 030e 	orr.w	r3, r3, lr
 8000f7a:	4323      	orrs	r3, r4
 8000f7c:	ea43 030c 	orr.w	r3, r3, ip
 8000f80:	ea43 0309 	orr.w	r3, r3, r9
 8000f84:	e7dc      	b.n	8000f40 <QSPI_Config+0x68>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000f86:	ea4a 0304 	orr.w	r3, sl, r4
 8000f8a:	ea43 0308 	orr.w	r3, r3, r8
 8000f8e:	ea43 030e 	orr.w	r3, r3, lr
 8000f92:	ea43 030c 	orr.w	r3, r3, ip
 8000f96:	ea43 0309 	orr.w	r3, r3, r9
 8000f9a:	e7e2      	b.n	8000f62 <QSPI_Config+0x8a>
    if (cmd->AlternateByteMode != QSPI_ALTERNATE_BYTES_NONE)
 8000f9c:	b365      	cbz	r5, 8000ff8 <QSPI_Config+0x120>
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
 8000f9e:	6804      	ldr	r4, [r0, #0]
 8000fa0:	688b      	ldr	r3, [r1, #8]
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000fa2:	6908      	ldr	r0, [r1, #16]
      WRITE_REG(hqspi->Instance->ABR, cmd->AlternateBytes);
 8000fa4:	61e3      	str	r3, [r4, #28]
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8000fa6:	ea46 0305 	orr.w	r3, r6, r5
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000faa:	694e      	ldr	r6, [r1, #20]
 8000fac:	ea43 0502 	orr.w	r5, r3, r2
 8000fb0:	f8d1 c034 	ldr.w	ip, [r1, #52]	; 0x34
 8000fb4:	04b6      	lsls	r6, r6, #18
 8000fb6:	e9d1 830b 	ldrd	r8, r3, [r1, #44]	; 0x2c
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8000fba:	b1a7      	cbz	r7, 8000fe6 <QSPI_Config+0x10e>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000fbc:	4338      	orrs	r0, r7
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 8000fbe:	f1b2 6f40 	cmp.w	r2, #201326592	; 0xc000000
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000fc2:	ea40 0008 	orr.w	r0, r0, r8
 8000fc6:	ea43 0300 	orr.w	r3, r3, r0
 8000fca:	68c8      	ldr	r0, [r1, #12]
 8000fcc:	ea43 030c 	orr.w	r3, r3, ip
 8000fd0:	ea43 0300 	orr.w	r3, r3, r0
 8000fd4:	ea43 0306 	orr.w	r3, r3, r6
 8000fd8:	ea43 0305 	orr.w	r3, r3, r5
 8000fdc:	6163      	str	r3, [r4, #20]
        if (FunctionalMode != QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED)
 8000fde:	d0c1      	beq.n	8000f64 <QSPI_Config+0x8c>
          WRITE_REG(hqspi->Instance->AR, cmd->Address);
 8000fe0:	684b      	ldr	r3, [r1, #4]
 8000fe2:	61a3      	str	r3, [r4, #24]
 8000fe4:	e7be      	b.n	8000f64 <QSPI_Config+0x8c>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000fe6:	ea40 0008 	orr.w	r0, r0, r8
 8000fea:	4303      	orrs	r3, r0
 8000fec:	ea43 030c 	orr.w	r3, r3, ip
 8000ff0:	4333      	orrs	r3, r6
 8000ff2:	432b      	orrs	r3, r5
 8000ff4:	6163      	str	r3, [r4, #20]
 8000ff6:	e7b5      	b.n	8000f64 <QSPI_Config+0x8c>
      if (cmd->AddressMode != QSPI_ADDRESS_NONE)
 8000ff8:	b17f      	cbz	r7, 800101a <QSPI_Config+0x142>
        WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 8000ffa:	ea46 0307 	orr.w	r3, r6, r7
 8000ffe:	6acc      	ldr	r4, [r1, #44]	; 0x2c
 8001000:	6800      	ldr	r0, [r0, #0]
 8001002:	4313      	orrs	r3, r2
 8001004:	4323      	orrs	r3, r4
 8001006:	6b0c      	ldr	r4, [r1, #48]	; 0x30
 8001008:	4323      	orrs	r3, r4
 800100a:	6b4c      	ldr	r4, [r1, #52]	; 0x34
 800100c:	4323      	orrs	r3, r4
 800100e:	68cc      	ldr	r4, [r1, #12]
 8001010:	4323      	orrs	r3, r4
 8001012:	694c      	ldr	r4, [r1, #20]
 8001014:	ea43 4384 	orr.w	r3, r3, r4, lsl #18
 8001018:	e792      	b.n	8000f40 <QSPI_Config+0x68>
        if (cmd->DataMode != QSPI_DATA_NONE)
 800101a:	2e00      	cmp	r6, #0
 800101c:	d0a2      	beq.n	8000f64 <QSPI_Config+0x8c>
          WRITE_REG(hqspi->Instance->CCR, (cmd->DdrMode | cmd->DdrHoldHalfCycle | cmd->SIOOMode |
 800101e:	6acb      	ldr	r3, [r1, #44]	; 0x2c
 8001020:	6800      	ldr	r0, [r0, #0]
 8001022:	4333      	orrs	r3, r6
 8001024:	6b0e      	ldr	r6, [r1, #48]	; 0x30
 8001026:	431a      	orrs	r2, r3
 8001028:	694b      	ldr	r3, [r1, #20]
 800102a:	4332      	orrs	r2, r6
 800102c:	6b4e      	ldr	r6, [r1, #52]	; 0x34
 800102e:	4332      	orrs	r2, r6
 8001030:	ea42 4283 	orr.w	r2, r2, r3, lsl #18
 8001034:	6142      	str	r2, [r0, #20]
}
 8001036:	e795      	b.n	8000f64 <QSPI_Config+0x8c>

08001038 <QSPI_WaitFlagStateUntilTimeout>:
{
 8001038:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800103c:	f8dd 8018 	ldr.w	r8, [sp, #24]
 8001040:	4604      	mov	r4, r0
 8001042:	460e      	mov	r6, r1
 8001044:	4615      	mov	r5, r2
 8001046:	461f      	mov	r7, r3
  while((__HAL_QSPI_GET_FLAG(hqspi, Flag)) != State)
 8001048:	6822      	ldr	r2, [r4, #0]
 800104a:	6893      	ldr	r3, [r2, #8]
 800104c:	4233      	tst	r3, r6
 800104e:	bf14      	ite	ne
 8001050:	2301      	movne	r3, #1
 8001052:	2300      	moveq	r3, #0
 8001054:	42ab      	cmp	r3, r5
 8001056:	d101      	bne.n	800105c <QSPI_WaitFlagStateUntilTimeout+0x24>
  return HAL_OK;
 8001058:	2000      	movs	r0, #0
 800105a:	e012      	b.n	8001082 <QSPI_WaitFlagStateUntilTimeout+0x4a>
    if (Timeout != HAL_MAX_DELAY)
 800105c:	f1b8 3fff 	cmp.w	r8, #4294967295
 8001060:	d0f3      	beq.n	800104a <QSPI_WaitFlagStateUntilTimeout+0x12>
      if(((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8001062:	f7ff fd6d 	bl	8000b40 <HAL_GetTick>
 8001066:	1bc0      	subs	r0, r0, r7
 8001068:	4540      	cmp	r0, r8
 800106a:	d802      	bhi.n	8001072 <QSPI_WaitFlagStateUntilTimeout+0x3a>
 800106c:	f1b8 0f00 	cmp.w	r8, #0
 8001070:	d1ea      	bne.n	8001048 <QSPI_WaitFlagStateUntilTimeout+0x10>
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 8001072:	2304      	movs	r3, #4
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 8001074:	2001      	movs	r0, #1
        hqspi->State     = HAL_QSPI_STATE_ERROR;
 8001076:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
        hqspi->ErrorCode |= HAL_QSPI_ERROR_TIMEOUT;
 800107a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800107c:	f043 0301 	orr.w	r3, r3, #1
 8001080:	6463      	str	r3, [r4, #68]	; 0x44
}
 8001082:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001086 <HAL_QSPI_MspInit>:
}
 8001086:	4770      	bx	lr

08001088 <HAL_QSPI_Init>:
{
 8001088:	b530      	push	{r4, r5, lr}
 800108a:	4604      	mov	r4, r0
 800108c:	b085      	sub	sp, #20
  uint32_t tickstart = HAL_GetTick();
 800108e:	f7ff fd57 	bl	8000b40 <HAL_GetTick>
 8001092:	4603      	mov	r3, r0
  if(hqspi == NULL)
 8001094:	2c00      	cmp	r4, #0
 8001096:	d040      	beq.n	800111a <HAL_QSPI_Init+0x92>
  if(hqspi->State == HAL_QSPI_STATE_RESET)
 8001098:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 800109c:	b93a      	cbnz	r2, 80010ae <HAL_QSPI_Init+0x26>
 800109e:	9003      	str	r0, [sp, #12]
    HAL_QSPI_MspInit(hqspi);
 80010a0:	4620      	mov	r0, r4
 80010a2:	f7ff fff0 	bl	8001086 <HAL_QSPI_MspInit>
  hqspi->Timeout = Timeout;
 80010a6:	f241 3288 	movw	r2, #5000	; 0x1388
 80010aa:	9b03      	ldr	r3, [sp, #12]
 80010ac:	64a2      	str	r2, [r4, #72]	; 0x48
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
 80010ae:	6820      	ldr	r0, [r4, #0]
 80010b0:	68a1      	ldr	r1, [r4, #8]
 80010b2:	6802      	ldr	r2, [r0, #0]
 80010b4:	3901      	subs	r1, #1
 80010b6:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
 80010ba:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 80010be:	2120      	movs	r1, #32
  MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_FTHRES,
 80010c0:	6002      	str	r2, [r0, #0]
  status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 80010c2:	4620      	mov	r0, r4
 80010c4:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 80010c6:	9200      	str	r2, [sp, #0]
 80010c8:	2200      	movs	r2, #0
 80010ca:	f7ff ffb5 	bl	8001038 <QSPI_WaitFlagStateUntilTimeout>
  if(status == HAL_OK)
 80010ce:	bb10      	cbnz	r0, 8001116 <HAL_QSPI_Init+0x8e>
    MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PRESCALER | QUADSPI_CR_SSHIFT | QUADSPI_CR_FSEL | QUADSPI_CR_DFM),
 80010d0:	6822      	ldr	r2, [r4, #0]
 80010d2:	69e5      	ldr	r5, [r4, #28]
 80010d4:	68e3      	ldr	r3, [r4, #12]
 80010d6:	6811      	ldr	r1, [r2, #0]
 80010d8:	432b      	orrs	r3, r5
 80010da:	6a25      	ldr	r5, [r4, #32]
 80010dc:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
 80010e0:	432b      	orrs	r3, r5
 80010e2:	6865      	ldr	r5, [r4, #4]
 80010e4:	f021 01d0 	bic.w	r1, r1, #208	; 0xd0
 80010e8:	ea43 6305 	orr.w	r3, r3, r5, lsl #24
 80010ec:	430b      	orrs	r3, r1
 80010ee:	6013      	str	r3, [r2, #0]
    MODIFY_REG(hqspi->Instance->DCR, (QUADSPI_DCR_FSIZE | QUADSPI_DCR_CSHT | QUADSPI_DCR_CKMODE),
 80010f0:	6855      	ldr	r5, [r2, #4]
 80010f2:	e9d4 3105 	ldrd	r3, r1, [r4, #20]
 80010f6:	430b      	orrs	r3, r1
 80010f8:	6921      	ldr	r1, [r4, #16]
 80010fa:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80010fe:	4908      	ldr	r1, [pc, #32]	; (8001120 <HAL_QSPI_Init+0x98>)
 8001100:	4029      	ands	r1, r5
 8001102:	430b      	orrs	r3, r1
 8001104:	6053      	str	r3, [r2, #4]
    __HAL_QSPI_ENABLE(hqspi);
 8001106:	6813      	ldr	r3, [r2, #0]
 8001108:	f043 0301 	orr.w	r3, r3, #1
 800110c:	6013      	str	r3, [r2, #0]
    hqspi->State = HAL_QSPI_STATE_READY;
 800110e:	2301      	movs	r3, #1
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8001110:	6460      	str	r0, [r4, #68]	; 0x44
    hqspi->State = HAL_QSPI_STATE_READY;
 8001112:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
}
 8001116:	b005      	add	sp, #20
 8001118:	bd30      	pop	{r4, r5, pc}
    return HAL_ERROR;
 800111a:	2001      	movs	r0, #1
 800111c:	e7fb      	b.n	8001116 <HAL_QSPI_Init+0x8e>
 800111e:	bf00      	nop
 8001120:	ffe0f8fe 	.word	0xffe0f8fe

08001124 <HAL_QSPI_MspDeInit>:
 8001124:	4770      	bx	lr

08001126 <HAL_QSPI_DeInit>:
{
 8001126:	b510      	push	{r4, lr}
  if(hqspi == NULL)
 8001128:	4604      	mov	r4, r0
 800112a:	b158      	cbz	r0, 8001144 <HAL_QSPI_DeInit+0x1e>
  __HAL_QSPI_DISABLE(hqspi);
 800112c:	6802      	ldr	r2, [r0, #0]
 800112e:	6813      	ldr	r3, [r2, #0]
 8001130:	f023 0301 	bic.w	r3, r3, #1
 8001134:	6013      	str	r3, [r2, #0]
  HAL_QSPI_MspDeInit(hqspi);
 8001136:	f7ff fff5 	bl	8001124 <HAL_QSPI_MspDeInit>
  hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 800113a:	2000      	movs	r0, #0
 800113c:	6460      	str	r0, [r4, #68]	; 0x44
  hqspi->State = HAL_QSPI_STATE_RESET;
 800113e:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
}
 8001142:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8001144:	2001      	movs	r0, #1
 8001146:	e7fc      	b.n	8001142 <HAL_QSPI_DeInit+0x1c>

08001148 <HAL_QSPI_Command>:
{
 8001148:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800114c:	4604      	mov	r4, r0
 800114e:	b085      	sub	sp, #20
 8001150:	4617      	mov	r7, r2
 8001152:	4689      	mov	r9, r1
  uint32_t tickstart = HAL_GetTick();
 8001154:	f7ff fcf4 	bl	8000b40 <HAL_GetTick>
  __HAL_LOCK(hqspi);
 8001158:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
  uint32_t tickstart = HAL_GetTick();
 800115c:	4603      	mov	r3, r0
  __HAL_LOCK(hqspi);
 800115e:	2a01      	cmp	r2, #1
 8001160:	d033      	beq.n	80011ca <HAL_QSPI_Command+0x82>
 8001162:	2201      	movs	r2, #1
 8001164:	2602      	movs	r6, #2
 8001166:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
 800116a:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 800116e:	2a01      	cmp	r2, #1
 8001170:	fa5f f882 	uxtb.w	r8, r2
 8001174:	d127      	bne.n	80011c6 <HAL_QSPI_Command+0x7e>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8001176:	2200      	movs	r2, #0
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 8001178:	9003      	str	r0, [sp, #12]
 800117a:	2120      	movs	r1, #32
 800117c:	4620      	mov	r0, r4
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 800117e:	6462      	str	r2, [r4, #68]	; 0x44
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 8001180:	9700      	str	r7, [sp, #0]
    hqspi->State = HAL_QSPI_STATE_BUSY;
 8001182:	f884 6041 	strb.w	r6, [r4, #65]	; 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 8001186:	f7ff ff57 	bl	8001038 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
 800118a:	4605      	mov	r5, r0
 800118c:	b9a0      	cbnz	r0, 80011b8 <HAL_QSPI_Command+0x70>
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
 800118e:	4602      	mov	r2, r0
 8001190:	4649      	mov	r1, r9
 8001192:	4620      	mov	r0, r4
 8001194:	f7ff fea0 	bl	8000ed8 <QSPI_Config>
      if (cmd->DataMode == QSPI_DATA_NONE)
 8001198:	f8d9 2024 	ldr.w	r2, [r9, #36]	; 0x24
 800119c:	9b03      	ldr	r3, [sp, #12]
 800119e:	b94a      	cbnz	r2, 80011b4 <HAL_QSPI_Command+0x6c>
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
 80011a0:	4642      	mov	r2, r8
 80011a2:	4631      	mov	r1, r6
 80011a4:	4620      	mov	r0, r4
 80011a6:	9700      	str	r7, [sp, #0]
 80011a8:	f7ff ff46 	bl	8001038 <QSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
 80011ac:	4605      	mov	r5, r0
 80011ae:	b918      	cbnz	r0, 80011b8 <HAL_QSPI_Command+0x70>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 80011b0:	6823      	ldr	r3, [r4, #0]
 80011b2:	60de      	str	r6, [r3, #12]
        hqspi->State = HAL_QSPI_STATE_READY;
 80011b4:	f884 8041 	strb.w	r8, [r4, #65]	; 0x41
  __HAL_UNLOCK(hqspi);
 80011b8:	2300      	movs	r3, #0
 80011ba:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 80011be:	4628      	mov	r0, r5
 80011c0:	b005      	add	sp, #20
 80011c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    status = HAL_BUSY;
 80011c6:	4635      	mov	r5, r6
 80011c8:	e7f6      	b.n	80011b8 <HAL_QSPI_Command+0x70>
  __HAL_LOCK(hqspi);
 80011ca:	2502      	movs	r5, #2
 80011cc:	e7f7      	b.n	80011be <HAL_QSPI_Command+0x76>

080011ce <HAL_QSPI_Transmit>:
{
 80011ce:	b5f0      	push	{r4, r5, r6, r7, lr}
 80011d0:	4604      	mov	r4, r0
 80011d2:	b085      	sub	sp, #20
 80011d4:	4616      	mov	r6, r2
 80011d6:	460f      	mov	r7, r1
  uint32_t tickstart = HAL_GetTick();
 80011d8:	f7ff fcb2 	bl	8000b40 <HAL_GetTick>
  __HAL_LOCK(hqspi);
 80011dc:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
  uint32_t tickstart = HAL_GetTick();
 80011e0:	4603      	mov	r3, r0
  __IO uint32_t *data_reg = &hqspi->Instance->DR;
 80011e2:	6825      	ldr	r5, [r4, #0]
  __HAL_LOCK(hqspi);
 80011e4:	2a01      	cmp	r2, #1
 80011e6:	d049      	beq.n	800127c <HAL_QSPI_Transmit+0xae>
 80011e8:	2201      	movs	r2, #1
 80011ea:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
 80011ee:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 80011f2:	2a01      	cmp	r2, #1
 80011f4:	b2d0      	uxtb	r0, r2
 80011f6:	d13f      	bne.n	8001278 <HAL_QSPI_Transmit+0xaa>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 80011f8:	2200      	movs	r2, #0
 80011fa:	6462      	str	r2, [r4, #68]	; 0x44
    if(pData != NULL )
 80011fc:	2f00      	cmp	r7, #0
 80011fe:	d036      	beq.n	800126e <HAL_QSPI_Transmit+0xa0>
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_TX;
 8001200:	2212      	movs	r2, #18
 8001202:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
      hqspi->TxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
 8001206:	692a      	ldr	r2, [r5, #16]
 8001208:	3201      	adds	r2, #1
 800120a:	62e2      	str	r2, [r4, #44]	; 0x2c
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
 800120c:	692a      	ldr	r2, [r5, #16]
      hqspi->pTxBuffPtr = pData;
 800120e:	6267      	str	r7, [r4, #36]	; 0x24
      hqspi->TxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
 8001210:	3201      	adds	r2, #1
 8001212:	62a2      	str	r2, [r4, #40]	; 0x28
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
 8001214:	696a      	ldr	r2, [r5, #20]
 8001216:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 800121a:	616a      	str	r2, [r5, #20]
      while(hqspi->TxXferCount > 0U)
 800121c:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 800121e:	b98a      	cbnz	r2, 8001244 <HAL_QSPI_Transmit+0x76>
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
 8001220:	2201      	movs	r2, #1
 8001222:	2102      	movs	r1, #2
 8001224:	4620      	mov	r0, r4
 8001226:	9600      	str	r6, [sp, #0]
 8001228:	f7ff ff06 	bl	8001038 <QSPI_WaitFlagStateUntilTimeout>
        if (status == HAL_OK)
 800122c:	b910      	cbnz	r0, 8001234 <HAL_QSPI_Transmit+0x66>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 800122e:	6823      	ldr	r3, [r4, #0]
 8001230:	2202      	movs	r2, #2
 8001232:	60da      	str	r2, [r3, #12]
      hqspi->State = HAL_QSPI_STATE_READY;
 8001234:	2301      	movs	r3, #1
 8001236:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hqspi);
 800123a:	2300      	movs	r3, #0
 800123c:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 8001240:	b005      	add	sp, #20
 8001242:	bdf0      	pop	{r4, r5, r6, r7, pc}
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_FT, SET, tickstart, Timeout);
 8001244:	2201      	movs	r2, #1
 8001246:	2104      	movs	r1, #4
 8001248:	4620      	mov	r0, r4
 800124a:	9600      	str	r6, [sp, #0]
 800124c:	9303      	str	r3, [sp, #12]
 800124e:	f7ff fef3 	bl	8001038 <QSPI_WaitFlagStateUntilTimeout>
        if (status != HAL_OK)
 8001252:	2800      	cmp	r0, #0
 8001254:	d1ee      	bne.n	8001234 <HAL_QSPI_Transmit+0x66>
        *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
 8001256:	6a62      	ldr	r2, [r4, #36]	; 0x24
        hqspi->TxXferCount--;
 8001258:	9b03      	ldr	r3, [sp, #12]
        *((__IO uint8_t *)data_reg) = *hqspi->pTxBuffPtr;
 800125a:	7812      	ldrb	r2, [r2, #0]
 800125c:	f885 2020 	strb.w	r2, [r5, #32]
        hqspi->pTxBuffPtr++;
 8001260:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001262:	3201      	adds	r2, #1
 8001264:	6262      	str	r2, [r4, #36]	; 0x24
        hqspi->TxXferCount--;
 8001266:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001268:	3a01      	subs	r2, #1
 800126a:	62e2      	str	r2, [r4, #44]	; 0x2c
 800126c:	e7d6      	b.n	800121c <HAL_QSPI_Transmit+0x4e>
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
 800126e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001270:	f043 0308 	orr.w	r3, r3, #8
 8001274:	6463      	str	r3, [r4, #68]	; 0x44
      status = HAL_ERROR;
 8001276:	e7e0      	b.n	800123a <HAL_QSPI_Transmit+0x6c>
    status = HAL_BUSY;
 8001278:	2002      	movs	r0, #2
 800127a:	e7de      	b.n	800123a <HAL_QSPI_Transmit+0x6c>
  __HAL_LOCK(hqspi);
 800127c:	2002      	movs	r0, #2
 800127e:	e7df      	b.n	8001240 <HAL_QSPI_Transmit+0x72>

08001280 <HAL_QSPI_Receive>:
{
 8001280:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001282:	4604      	mov	r4, r0
 8001284:	b085      	sub	sp, #20
 8001286:	4616      	mov	r6, r2
 8001288:	460f      	mov	r7, r1
  uint32_t tickstart = HAL_GetTick();
 800128a:	f7ff fc59 	bl	8000b40 <HAL_GetTick>
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
 800128e:	6825      	ldr	r5, [r4, #0]
  uint32_t tickstart = HAL_GetTick();
 8001290:	4603      	mov	r3, r0
  uint32_t addr_reg = READ_REG(hqspi->Instance->AR);
 8001292:	f8d5 c018 	ldr.w	ip, [r5, #24]
  __HAL_LOCK(hqspi);
 8001296:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
 800129a:	2a01      	cmp	r2, #1
 800129c:	d04d      	beq.n	800133a <HAL_QSPI_Receive+0xba>
 800129e:	2201      	movs	r2, #1
 80012a0:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
 80012a4:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 80012a8:	2a01      	cmp	r2, #1
 80012aa:	b2d0      	uxtb	r0, r2
 80012ac:	d143      	bne.n	8001336 <HAL_QSPI_Receive+0xb6>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 80012ae:	2200      	movs	r2, #0
 80012b0:	6462      	str	r2, [r4, #68]	; 0x44
    if(pData != NULL )
 80012b2:	2f00      	cmp	r7, #0
 80012b4:	d03a      	beq.n	800132c <HAL_QSPI_Receive+0xac>
      hqspi->State = HAL_QSPI_STATE_BUSY_INDIRECT_RX;
 80012b6:	2222      	movs	r2, #34	; 0x22
 80012b8:	f884 2041 	strb.w	r2, [r4, #65]	; 0x41
      hqspi->RxXferCount = READ_REG(hqspi->Instance->DLR) + 1U;
 80012bc:	692a      	ldr	r2, [r5, #16]
 80012be:	3201      	adds	r2, #1
 80012c0:	63a2      	str	r2, [r4, #56]	; 0x38
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
 80012c2:	692a      	ldr	r2, [r5, #16]
      hqspi->pRxBuffPtr = pData;
 80012c4:	6327      	str	r7, [r4, #48]	; 0x30
      hqspi->RxXferSize = READ_REG(hqspi->Instance->DLR) + 1U;
 80012c6:	3201      	adds	r2, #1
 80012c8:	6362      	str	r2, [r4, #52]	; 0x34
      MODIFY_REG(hqspi->Instance->CCR, QUADSPI_CCR_FMODE, QSPI_FUNCTIONAL_MODE_INDIRECT_READ);
 80012ca:	6969      	ldr	r1, [r5, #20]
 80012cc:	f021 6140 	bic.w	r1, r1, #201326592	; 0xc000000
 80012d0:	f041 6180 	orr.w	r1, r1, #67108864	; 0x4000000
 80012d4:	6169      	str	r1, [r5, #20]
      WRITE_REG(hqspi->Instance->AR, addr_reg);
 80012d6:	f8c5 c018 	str.w	ip, [r5, #24]
      while(hqspi->RxXferCount > 0U)
 80012da:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 80012dc:	b98a      	cbnz	r2, 8001302 <HAL_QSPI_Receive+0x82>
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_TC, SET, tickstart, Timeout);
 80012de:	2201      	movs	r2, #1
 80012e0:	2102      	movs	r1, #2
 80012e2:	4620      	mov	r0, r4
 80012e4:	9600      	str	r6, [sp, #0]
 80012e6:	f7ff fea7 	bl	8001038 <QSPI_WaitFlagStateUntilTimeout>
        if  (status == HAL_OK)
 80012ea:	b910      	cbnz	r0, 80012f2 <HAL_QSPI_Receive+0x72>
          __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TC);
 80012ec:	6823      	ldr	r3, [r4, #0]
 80012ee:	2202      	movs	r2, #2
 80012f0:	60da      	str	r2, [r3, #12]
      hqspi->State = HAL_QSPI_STATE_READY;
 80012f2:	2301      	movs	r3, #1
 80012f4:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_UNLOCK(hqspi);
 80012f8:	2300      	movs	r3, #0
 80012fa:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 80012fe:	b005      	add	sp, #20
 8001300:	bdf0      	pop	{r4, r5, r6, r7, pc}
        status = QSPI_WaitFlagStateUntilTimeout(hqspi, (QSPI_FLAG_FT | QSPI_FLAG_TC), SET, tickstart, Timeout);
 8001302:	2201      	movs	r2, #1
 8001304:	2106      	movs	r1, #6
 8001306:	4620      	mov	r0, r4
 8001308:	9600      	str	r6, [sp, #0]
 800130a:	9303      	str	r3, [sp, #12]
 800130c:	f7ff fe94 	bl	8001038 <QSPI_WaitFlagStateUntilTimeout>
        if  (status != HAL_OK)
 8001310:	2800      	cmp	r0, #0
 8001312:	d1ee      	bne.n	80012f2 <HAL_QSPI_Receive+0x72>
        *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
 8001314:	f895 1020 	ldrb.w	r1, [r5, #32]
 8001318:	6b22      	ldr	r2, [r4, #48]	; 0x30
        hqspi->RxXferCount--;
 800131a:	9b03      	ldr	r3, [sp, #12]
        *hqspi->pRxBuffPtr = *((__IO uint8_t *)data_reg);
 800131c:	7011      	strb	r1, [r2, #0]
        hqspi->pRxBuffPtr++;
 800131e:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8001320:	3201      	adds	r2, #1
 8001322:	6322      	str	r2, [r4, #48]	; 0x30
        hqspi->RxXferCount--;
 8001324:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001326:	3a01      	subs	r2, #1
 8001328:	63a2      	str	r2, [r4, #56]	; 0x38
 800132a:	e7d6      	b.n	80012da <HAL_QSPI_Receive+0x5a>
      hqspi->ErrorCode |= HAL_QSPI_ERROR_INVALID_PARAM;
 800132c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800132e:	f043 0308 	orr.w	r3, r3, #8
 8001332:	6463      	str	r3, [r4, #68]	; 0x44
      status = HAL_ERROR;
 8001334:	e7e0      	b.n	80012f8 <HAL_QSPI_Receive+0x78>
    status = HAL_BUSY;
 8001336:	2002      	movs	r0, #2
 8001338:	e7de      	b.n	80012f8 <HAL_QSPI_Receive+0x78>
  __HAL_LOCK(hqspi);
 800133a:	2002      	movs	r0, #2
 800133c:	e7df      	b.n	80012fe <HAL_QSPI_Receive+0x7e>

0800133e <HAL_QSPI_AutoPolling>:
{
 800133e:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 8001342:	4604      	mov	r4, r0
 8001344:	4615      	mov	r5, r2
 8001346:	461e      	mov	r6, r3
 8001348:	4688      	mov	r8, r1
  uint32_t tickstart = HAL_GetTick();
 800134a:	f7ff fbf9 	bl	8000b40 <HAL_GetTick>
  __HAL_LOCK(hqspi);
 800134e:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
  uint32_t tickstart = HAL_GetTick();
 8001352:	4603      	mov	r3, r0
  __HAL_LOCK(hqspi);
 8001354:	2a01      	cmp	r2, #1
 8001356:	d040      	beq.n	80013da <HAL_QSPI_AutoPolling+0x9c>
 8001358:	2201      	movs	r2, #1
 800135a:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
 800135e:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 8001362:	2a01      	cmp	r2, #1
 8001364:	b2d7      	uxtb	r7, r2
 8001366:	d136      	bne.n	80013d6 <HAL_QSPI_AutoPolling+0x98>
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
 8001368:	2142      	movs	r1, #66	; 0x42
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 800136a:	2200      	movs	r2, #0
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 800136c:	9003      	str	r0, [sp, #12]
 800136e:	4620      	mov	r0, r4
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8001370:	6462      	str	r2, [r4, #68]	; 0x44
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 8001372:	9600      	str	r6, [sp, #0]
    hqspi->State = HAL_QSPI_STATE_BUSY_AUTO_POLLING;
 8001374:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, Timeout);
 8001378:	2120      	movs	r1, #32
 800137a:	f7ff fe5d 	bl	8001038 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
 800137e:	bb20      	cbnz	r0, 80013ca <HAL_QSPI_AutoPolling+0x8c>
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
 8001380:	6821      	ldr	r1, [r4, #0]
 8001382:	682a      	ldr	r2, [r5, #0]
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
 8001384:	6928      	ldr	r0, [r5, #16]
      WRITE_REG(hqspi->Instance->PSMAR, cfg->Match);
 8001386:	628a      	str	r2, [r1, #40]	; 0x28
      WRITE_REG(hqspi->Instance->PSMKR, cfg->Mask);
 8001388:	686a      	ldr	r2, [r5, #4]
 800138a:	624a      	str	r2, [r1, #36]	; 0x24
      WRITE_REG(hqspi->Instance->PIR, cfg->Interval);
 800138c:	68aa      	ldr	r2, [r5, #8]
 800138e:	62ca      	str	r2, [r1, #44]	; 0x2c
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
 8001390:	680a      	ldr	r2, [r1, #0]
 8001392:	f422 0240 	bic.w	r2, r2, #12582912	; 0xc00000
 8001396:	4302      	orrs	r2, r0
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
 8001398:	4620      	mov	r0, r4
      MODIFY_REG(hqspi->Instance->CR, (QUADSPI_CR_PMM | QUADSPI_CR_APMS),
 800139a:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 800139e:	600a      	str	r2, [r1, #0]
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
 80013a0:	4641      	mov	r1, r8
      cmd->NbData = cfg->StatusBytesSize;
 80013a2:	68ea      	ldr	r2, [r5, #12]
 80013a4:	f8c8 2028 	str.w	r2, [r8, #40]	; 0x28
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_AUTO_POLLING);
 80013a8:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80013ac:	f7ff fd94 	bl	8000ed8 <QSPI_Config>
      status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_SM, SET, tickstart, Timeout);
 80013b0:	9b03      	ldr	r3, [sp, #12]
 80013b2:	463a      	mov	r2, r7
 80013b4:	2108      	movs	r1, #8
 80013b6:	4620      	mov	r0, r4
 80013b8:	9600      	str	r6, [sp, #0]
 80013ba:	f7ff fe3d 	bl	8001038 <QSPI_WaitFlagStateUntilTimeout>
      if (status == HAL_OK)
 80013be:	b920      	cbnz	r0, 80013ca <HAL_QSPI_AutoPolling+0x8c>
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_SM);
 80013c0:	6823      	ldr	r3, [r4, #0]
 80013c2:	2208      	movs	r2, #8
 80013c4:	60da      	str	r2, [r3, #12]
        hqspi->State = HAL_QSPI_STATE_READY;
 80013c6:	f884 7041 	strb.w	r7, [r4, #65]	; 0x41
  __HAL_UNLOCK(hqspi);
 80013ca:	2300      	movs	r3, #0
 80013cc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 80013d0:	b004      	add	sp, #16
 80013d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    status = HAL_BUSY;
 80013d6:	2002      	movs	r0, #2
 80013d8:	e7f7      	b.n	80013ca <HAL_QSPI_AutoPolling+0x8c>
  __HAL_LOCK(hqspi);
 80013da:	2002      	movs	r0, #2
 80013dc:	e7f8      	b.n	80013d0 <HAL_QSPI_AutoPolling+0x92>

080013de <HAL_QSPI_MemoryMapped>:
{
 80013de:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80013e0:	4604      	mov	r4, r0
 80013e2:	4616      	mov	r6, r2
 80013e4:	460f      	mov	r7, r1
  uint32_t tickstart = HAL_GetTick();
 80013e6:	f7ff fbab 	bl	8000b40 <HAL_GetTick>
  __HAL_LOCK(hqspi);
 80013ea:	f894 2040 	ldrb.w	r2, [r4, #64]	; 0x40
  uint32_t tickstart = HAL_GetTick();
 80013ee:	4603      	mov	r3, r0
  __HAL_LOCK(hqspi);
 80013f0:	2a01      	cmp	r2, #1
 80013f2:	d033      	beq.n	800145c <HAL_QSPI_MemoryMapped+0x7e>
 80013f4:	2201      	movs	r2, #1
 80013f6:	f884 2040 	strb.w	r2, [r4, #64]	; 0x40
  if(hqspi->State == HAL_QSPI_STATE_READY)
 80013fa:	f894 2041 	ldrb.w	r2, [r4, #65]	; 0x41
 80013fe:	2a01      	cmp	r2, #1
 8001400:	d12a      	bne.n	8001458 <HAL_QSPI_MemoryMapped+0x7a>
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8001402:	2200      	movs	r2, #0
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
 8001404:	2182      	movs	r1, #130	; 0x82
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 8001406:	4620      	mov	r0, r4
    hqspi->ErrorCode = HAL_QSPI_ERROR_NONE;
 8001408:	6462      	str	r2, [r4, #68]	; 0x44
    hqspi->State = HAL_QSPI_STATE_BUSY_MEM_MAPPED;
 800140a:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    status = QSPI_WaitFlagStateUntilTimeout(hqspi, QSPI_FLAG_BUSY, RESET, tickstart, hqspi->Timeout);
 800140e:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 8001410:	9100      	str	r1, [sp, #0]
 8001412:	2120      	movs	r1, #32
 8001414:	f7ff fe10 	bl	8001038 <QSPI_WaitFlagStateUntilTimeout>
    if (status == HAL_OK)
 8001418:	4605      	mov	r5, r0
 800141a:	b9b8      	cbnz	r0, 800144c <HAL_QSPI_MemoryMapped+0x6e>
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
 800141c:	6823      	ldr	r3, [r4, #0]
 800141e:	6872      	ldr	r2, [r6, #4]
 8001420:	6818      	ldr	r0, [r3, #0]
    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
 8001422:	2a08      	cmp	r2, #8
    MODIFY_REG(hqspi->Instance->CR, QUADSPI_CR_TCEN, cfg->TimeOutActivation);
 8001424:	f020 0008 	bic.w	r0, r0, #8
 8001428:	ea40 0002 	orr.w	r0, r0, r2
 800142c:	6018      	str	r0, [r3, #0]
    if (cfg->TimeOutActivation == QSPI_TIMEOUT_COUNTER_ENABLE)
 800142e:	d107      	bne.n	8001440 <HAL_QSPI_MemoryMapped+0x62>
        WRITE_REG(hqspi->Instance->LPTR, cfg->TimeOutPeriod);
 8001430:	6832      	ldr	r2, [r6, #0]
 8001432:	631a      	str	r2, [r3, #48]	; 0x30
        __HAL_QSPI_CLEAR_FLAG(hqspi, QSPI_FLAG_TO);
 8001434:	2210      	movs	r2, #16
 8001436:	60da      	str	r2, [r3, #12]
        __HAL_QSPI_ENABLE_IT(hqspi, QSPI_IT_TO);
 8001438:	681a      	ldr	r2, [r3, #0]
 800143a:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800143e:	601a      	str	r2, [r3, #0]
      QSPI_Config(hqspi, cmd, QSPI_FUNCTIONAL_MODE_MEMORY_MAPPED);
 8001440:	f04f 6240 	mov.w	r2, #201326592	; 0xc000000
 8001444:	4639      	mov	r1, r7
 8001446:	4620      	mov	r0, r4
 8001448:	f7ff fd46 	bl	8000ed8 <QSPI_Config>
  __HAL_UNLOCK(hqspi);
 800144c:	2300      	movs	r3, #0
 800144e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
}
 8001452:	4628      	mov	r0, r5
 8001454:	b003      	add	sp, #12
 8001456:	bdf0      	pop	{r4, r5, r6, r7, pc}
    status = HAL_BUSY;
 8001458:	2502      	movs	r5, #2
 800145a:	e7f7      	b.n	800144c <HAL_QSPI_MemoryMapped+0x6e>
  __HAL_LOCK(hqspi);
 800145c:	2502      	movs	r5, #2
 800145e:	e7f8      	b.n	8001452 <HAL_QSPI_MemoryMapped+0x74>

08001460 <HAL_RCC_OscConfig>:
  *         supported by this function. User should request a transition to HSE Off
  *         first and then HSE On or HSE Bypass.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_RCC_OscConfig(RCC_OscInitTypeDef  *RCC_OscInitStruct)
{
 8001460:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  uint32_t tickstart;
  uint32_t temp1_pllckcfg, temp2_pllckcfg;

    /* Check Null pointer */
  if(RCC_OscInitStruct == NULL)
 8001462:	4604      	mov	r4, r0
 8001464:	b908      	cbnz	r0, 800146a <HAL_RCC_OscConfig+0xa>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
      {
        return HAL_ERROR;
 8001466:	2001      	movs	r0, #1
 8001468:	e08b      	b.n	8001582 <HAL_RCC_OscConfig+0x122>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 800146a:	6803      	ldr	r3, [r0, #0]
 800146c:	07df      	lsls	r7, r3, #31
 800146e:	d45e      	bmi.n	800152e <HAL_RCC_OscConfig+0xce>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8001470:	6823      	ldr	r3, [r4, #0]
 8001472:	079e      	lsls	r6, r3, #30
 8001474:	f100 80af 	bmi.w	80015d6 <HAL_RCC_OscConfig+0x176>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_CSI) == RCC_OSCILLATORTYPE_CSI)
 8001478:	6823      	ldr	r3, [r4, #0]
 800147a:	06da      	lsls	r2, r3, #27
 800147c:	d527      	bpl.n	80014ce <HAL_RCC_OscConfig+0x6e>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800147e:	4b9e      	ldr	r3, [pc, #632]	; (80016f8 <HAL_RCC_OscConfig+0x298>)
 8001480:	691a      	ldr	r2, [r3, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8001482:	6a99      	ldr	r1, [r3, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001484:	f002 0238 	and.w	r2, r2, #56	; 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_CSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_CSI)))
 8001488:	2a08      	cmp	r2, #8
 800148a:	d007      	beq.n	800149c <HAL_RCC_OscConfig+0x3c>
 800148c:	2a18      	cmp	r2, #24
 800148e:	f040 8107 	bne.w	80016a0 <HAL_RCC_OscConfig+0x240>
 8001492:	f001 0203 	and.w	r2, r1, #3
 8001496:	2a01      	cmp	r2, #1
 8001498:	f040 8102 	bne.w	80016a0 <HAL_RCC_OscConfig+0x240>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U) && (RCC_OscInitStruct->CSIState != RCC_CSI_ON))
 800149c:	681b      	ldr	r3, [r3, #0]
 800149e:	05db      	lsls	r3, r3, #23
 80014a0:	d502      	bpl.n	80014a8 <HAL_RCC_OscConfig+0x48>
 80014a2:	69e3      	ldr	r3, [r4, #28]
 80014a4:	2b80      	cmp	r3, #128	; 0x80
 80014a6:	d1de      	bne.n	8001466 <HAL_RCC_OscConfig+0x6>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 80014a8:	f7ff fb50 	bl	8000b4c <HAL_GetREVID>
 80014ac:	f241 0303 	movw	r3, #4099	; 0x1003
 80014b0:	6a21      	ldr	r1, [r4, #32]
 80014b2:	4298      	cmp	r0, r3
 80014b4:	4b90      	ldr	r3, [pc, #576]	; (80016f8 <HAL_RCC_OscConfig+0x298>)
 80014b6:	f200 80ec 	bhi.w	8001692 <HAL_RCC_OscConfig+0x232>
 80014ba:	685a      	ldr	r2, [r3, #4]
 80014bc:	2920      	cmp	r1, #32
 80014be:	f022 42f8 	bic.w	r2, r2, #2080374784	; 0x7c000000
 80014c2:	bf0c      	ite	eq
 80014c4:	f042 4280 	orreq.w	r2, r2, #1073741824	; 0x40000000
 80014c8:	ea42 6281 	orrne.w	r2, r2, r1, lsl #26
 80014cc:	605a      	str	r2, [r3, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80014ce:	6823      	ldr	r3, [r4, #0]
 80014d0:	0719      	lsls	r1, r3, #28
 80014d2:	f100 8127 	bmi.w	8001724 <HAL_RCC_OscConfig+0x2c4>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 80014d6:	6823      	ldr	r3, [r4, #0]
 80014d8:	069a      	lsls	r2, r3, #26
 80014da:	f100 8148 	bmi.w	800176e <HAL_RCC_OscConfig+0x30e>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80014de:	6823      	ldr	r3, [r4, #0]
 80014e0:	075d      	lsls	r5, r3, #29
 80014e2:	d51e      	bpl.n	8001522 <HAL_RCC_OscConfig+0xc2>
    PWR->CR1 |= PWR_CR1_DBP;
 80014e4:	4d85      	ldr	r5, [pc, #532]	; (80016fc <HAL_RCC_OscConfig+0x29c>)
 80014e6:	682b      	ldr	r3, [r5, #0]
 80014e8:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80014ec:	602b      	str	r3, [r5, #0]
    tickstart = HAL_GetTick();
 80014ee:	f7ff fb27 	bl	8000b40 <HAL_GetTick>
 80014f2:	4606      	mov	r6, r0
    while((PWR->CR1 & PWR_CR1_DBP) == 0U)
 80014f4:	682b      	ldr	r3, [r5, #0]
 80014f6:	05da      	lsls	r2, r3, #23
 80014f8:	f140 815e 	bpl.w	80017b8 <HAL_RCC_OscConfig+0x358>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80014fc:	68a3      	ldr	r3, [r4, #8]
 80014fe:	4d7e      	ldr	r5, [pc, #504]	; (80016f8 <HAL_RCC_OscConfig+0x298>)
 8001500:	2b01      	cmp	r3, #1
 8001502:	f040 8160 	bne.w	80017c6 <HAL_RCC_OscConfig+0x366>
 8001506:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 8001508:	f043 0301 	orr.w	r3, r3, #1
 800150c:	672b      	str	r3, [r5, #112]	; 0x70
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 800150e:	f241 3788 	movw	r7, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8001512:	f7ff fb15 	bl	8000b40 <HAL_GetTick>
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 8001516:	4e78      	ldr	r6, [pc, #480]	; (80016f8 <HAL_RCC_OscConfig+0x298>)
      tickstart = HAL_GetTick();
 8001518:	4605      	mov	r5, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) == 0U)
 800151a:	6f33      	ldr	r3, [r6, #112]	; 0x70
 800151c:	079b      	lsls	r3, r3, #30
 800151e:	f140 8178 	bpl.w	8001812 <HAL_RCC_OscConfig+0x3b2>
  if ((RCC_OscInitStruct->PLL.PLLState) != RCC_PLL_NONE)
 8001522:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8001524:	2800      	cmp	r0, #0
 8001526:	f040 817b 	bne.w	8001820 <HAL_RCC_OscConfig+0x3c0>
      }
    }
  }
  return HAL_OK;
 800152a:	2000      	movs	r0, #0
 800152c:	e029      	b.n	8001582 <HAL_RCC_OscConfig+0x122>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 800152e:	4b72      	ldr	r3, [pc, #456]	; (80016f8 <HAL_RCC_OscConfig+0x298>)
 8001530:	691a      	ldr	r2, [r3, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 8001532:	6a99      	ldr	r1, [r3, #40]	; 0x28
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 8001534:	f002 0238 	and.w	r2, r2, #56	; 0x38
    if((temp_sysclksrc == RCC_CFGR_SWS_HSE) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSE)))
 8001538:	2a10      	cmp	r2, #16
 800153a:	d005      	beq.n	8001548 <HAL_RCC_OscConfig+0xe8>
 800153c:	2a18      	cmp	r2, #24
 800153e:	d10a      	bne.n	8001556 <HAL_RCC_OscConfig+0xf6>
 8001540:	f001 0203 	and.w	r2, r1, #3
 8001544:	2a02      	cmp	r2, #2
 8001546:	d106      	bne.n	8001556 <HAL_RCC_OscConfig+0xf6>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8001548:	681b      	ldr	r3, [r3, #0]
 800154a:	039d      	lsls	r5, r3, #14
 800154c:	d590      	bpl.n	8001470 <HAL_RCC_OscConfig+0x10>
 800154e:	6863      	ldr	r3, [r4, #4]
 8001550:	2b00      	cmp	r3, #0
 8001552:	d18d      	bne.n	8001470 <HAL_RCC_OscConfig+0x10>
 8001554:	e787      	b.n	8001466 <HAL_RCC_OscConfig+0x6>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001556:	6862      	ldr	r2, [r4, #4]
 8001558:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 800155c:	d112      	bne.n	8001584 <HAL_RCC_OscConfig+0x124>
 800155e:	681a      	ldr	r2, [r3, #0]
 8001560:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8001564:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001566:	f7ff faeb 	bl	8000b40 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800156a:	4e63      	ldr	r6, [pc, #396]	; (80016f8 <HAL_RCC_OscConfig+0x298>)
        tickstart = HAL_GetTick();
 800156c:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 800156e:	6833      	ldr	r3, [r6, #0]
 8001570:	0398      	lsls	r0, r3, #14
 8001572:	f53f af7d 	bmi.w	8001470 <HAL_RCC_OscConfig+0x10>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 8001576:	f7ff fae3 	bl	8000b40 <HAL_GetTick>
 800157a:	1b40      	subs	r0, r0, r5
 800157c:	2864      	cmp	r0, #100	; 0x64
 800157e:	d9f6      	bls.n	800156e <HAL_RCC_OscConfig+0x10e>
            return HAL_TIMEOUT;
 8001580:	2003      	movs	r0, #3
}
 8001582:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8001584:	4d5c      	ldr	r5, [pc, #368]	; (80016f8 <HAL_RCC_OscConfig+0x298>)
 8001586:	682b      	ldr	r3, [r5, #0]
 8001588:	b99a      	cbnz	r2, 80015b2 <HAL_RCC_OscConfig+0x152>
 800158a:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 800158e:	602b      	str	r3, [r5, #0]
 8001590:	682b      	ldr	r3, [r5, #0]
 8001592:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 8001596:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 8001598:	f7ff fad2 	bl	8000b40 <HAL_GetTick>
 800159c:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) != 0U)
 800159e:	682b      	ldr	r3, [r5, #0]
 80015a0:	0399      	lsls	r1, r3, #14
 80015a2:	f57f af65 	bpl.w	8001470 <HAL_RCC_OscConfig+0x10>
          if((uint32_t) (HAL_GetTick() - tickstart ) > HSE_TIMEOUT_VALUE)
 80015a6:	f7ff facb 	bl	8000b40 <HAL_GetTick>
 80015aa:	1b80      	subs	r0, r0, r6
 80015ac:	2864      	cmp	r0, #100	; 0x64
 80015ae:	d9f6      	bls.n	800159e <HAL_RCC_OscConfig+0x13e>
 80015b0:	e7e6      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 80015b2:	f5b2 2fa0 	cmp.w	r2, #327680	; 0x50000
 80015b6:	d107      	bne.n	80015c8 <HAL_RCC_OscConfig+0x168>
 80015b8:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80015bc:	602b      	str	r3, [r5, #0]
 80015be:	682b      	ldr	r3, [r5, #0]
 80015c0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80015c4:	602b      	str	r3, [r5, #0]
 80015c6:	e7ce      	b.n	8001566 <HAL_RCC_OscConfig+0x106>
 80015c8:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80015cc:	602b      	str	r3, [r5, #0]
 80015ce:	682b      	ldr	r3, [r5, #0]
 80015d0:	f423 2380 	bic.w	r3, r3, #262144	; 0x40000
 80015d4:	e7f6      	b.n	80015c4 <HAL_RCC_OscConfig+0x164>
    const uint32_t temp_sysclksrc = __HAL_RCC_GET_SYSCLK_SOURCE();
 80015d6:	4b48      	ldr	r3, [pc, #288]	; (80016f8 <HAL_RCC_OscConfig+0x298>)
 80015d8:	68e1      	ldr	r1, [r4, #12]
 80015da:	691a      	ldr	r2, [r3, #16]
    const uint32_t temp_pllckselr = RCC->PLLCKSELR;
 80015dc:	6a98      	ldr	r0, [r3, #40]	; 0x28
    if((temp_sysclksrc == RCC_CFGR_SWS_HSI) || ((temp_sysclksrc == RCC_CFGR_SWS_PLL1) && ((temp_pllckselr & RCC_PLLCKSELR_PLLSRC) == RCC_PLLCKSELR_PLLSRC_HSI)))
 80015de:	f012 0238 	ands.w	r2, r2, #56	; 0x38
 80015e2:	d003      	beq.n	80015ec <HAL_RCC_OscConfig+0x18c>
 80015e4:	2a18      	cmp	r2, #24
 80015e6:	d12b      	bne.n	8001640 <HAL_RCC_OscConfig+0x1e0>
 80015e8:	0782      	lsls	r2, r0, #30
 80015ea:	d129      	bne.n	8001640 <HAL_RCC_OscConfig+0x1e0>
      if((__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80015ec:	681b      	ldr	r3, [r3, #0]
 80015ee:	075b      	lsls	r3, r3, #29
 80015f0:	d502      	bpl.n	80015f8 <HAL_RCC_OscConfig+0x198>
 80015f2:	2900      	cmp	r1, #0
 80015f4:	f43f af37 	beq.w	8001466 <HAL_RCC_OscConfig+0x6>
          __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 80015f8:	4d3f      	ldr	r5, [pc, #252]	; (80016f8 <HAL_RCC_OscConfig+0x298>)
 80015fa:	682a      	ldr	r2, [r5, #0]
 80015fc:	f022 0219 	bic.w	r2, r2, #25
 8001600:	430a      	orrs	r2, r1
 8001602:	602a      	str	r2, [r5, #0]
          tickstart = HAL_GetTick();
 8001604:	f7ff fa9c 	bl	8000b40 <HAL_GetTick>
 8001608:	4606      	mov	r6, r0
          while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 800160a:	682b      	ldr	r3, [r5, #0]
 800160c:	075f      	lsls	r7, r3, #29
 800160e:	d511      	bpl.n	8001634 <HAL_RCC_OscConfig+0x1d4>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001610:	f7ff fa9c 	bl	8000b4c <HAL_GetREVID>
 8001614:	f241 0303 	movw	r3, #4099	; 0x1003
 8001618:	6922      	ldr	r2, [r4, #16]
 800161a:	4298      	cmp	r0, r3
 800161c:	686b      	ldr	r3, [r5, #4]
 800161e:	d822      	bhi.n	8001666 <HAL_RCC_OscConfig+0x206>
 8001620:	f423 337c 	bic.w	r3, r3, #258048	; 0x3f000
 8001624:	2a40      	cmp	r2, #64	; 0x40
 8001626:	bf0c      	ite	eq
 8001628:	f443 3300 	orreq.w	r3, r3, #131072	; 0x20000
 800162c:	ea43 3302 	orrne.w	r3, r3, r2, lsl #12
 8001630:	606b      	str	r3, [r5, #4]
 8001632:	e721      	b.n	8001478 <HAL_RCC_OscConfig+0x18>
            if((uint32_t) (HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001634:	f7ff fa84 	bl	8000b40 <HAL_GetTick>
 8001638:	1b80      	subs	r0, r0, r6
 800163a:	2802      	cmp	r0, #2
 800163c:	d9e5      	bls.n	800160a <HAL_RCC_OscConfig+0x1aa>
 800163e:	e79f      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 8001640:	681a      	ldr	r2, [r3, #0]
      if((RCC_OscInitStruct->HSIState)!= RCC_HSI_OFF)
 8001642:	b1a9      	cbz	r1, 8001670 <HAL_RCC_OscConfig+0x210>
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 8001644:	f022 0219 	bic.w	r2, r2, #25
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8001648:	4d2b      	ldr	r5, [pc, #172]	; (80016f8 <HAL_RCC_OscConfig+0x298>)
        __HAL_RCC_HSI_CONFIG(RCC_OscInitStruct->HSIState);
 800164a:	430a      	orrs	r2, r1
 800164c:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800164e:	f7ff fa77 	bl	8000b40 <HAL_GetTick>
 8001652:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8001654:	682b      	ldr	r3, [r5, #0]
 8001656:	0758      	lsls	r0, r3, #29
 8001658:	d4da      	bmi.n	8001610 <HAL_RCC_OscConfig+0x1b0>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 800165a:	f7ff fa71 	bl	8000b40 <HAL_GetTick>
 800165e:	1b80      	subs	r0, r0, r6
 8001660:	2802      	cmp	r0, #2
 8001662:	d9f7      	bls.n	8001654 <HAL_RCC_OscConfig+0x1f4>
 8001664:	e78c      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8001666:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 800166a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 800166e:	e7df      	b.n	8001630 <HAL_RCC_OscConfig+0x1d0>
        __HAL_RCC_HSI_DISABLE();
 8001670:	f022 0201 	bic.w	r2, r2, #1
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 8001674:	4e20      	ldr	r6, [pc, #128]	; (80016f8 <HAL_RCC_OscConfig+0x298>)
        __HAL_RCC_HSI_DISABLE();
 8001676:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 8001678:	f7ff fa62 	bl	8000b40 <HAL_GetTick>
 800167c:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) != 0U)
 800167e:	6833      	ldr	r3, [r6, #0]
 8001680:	0759      	lsls	r1, r3, #29
 8001682:	f57f aef9 	bpl.w	8001478 <HAL_RCC_OscConfig+0x18>
          if((HAL_GetTick() - tickstart ) > HSI_TIMEOUT_VALUE)
 8001686:	f7ff fa5b 	bl	8000b40 <HAL_GetTick>
 800168a:	1b40      	subs	r0, r0, r5
 800168c:	2802      	cmp	r0, #2
 800168e:	d9f6      	bls.n	800167e <HAL_RCC_OscConfig+0x21e>
 8001690:	e776      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 8001692:	68da      	ldr	r2, [r3, #12]
 8001694:	f022 527c 	bic.w	r2, r2, #1056964608	; 0x3f000000
 8001698:	ea42 6201 	orr.w	r2, r2, r1, lsl #24
 800169c:	60da      	str	r2, [r3, #12]
 800169e:	e716      	b.n	80014ce <HAL_RCC_OscConfig+0x6e>
      if((RCC_OscInitStruct->CSIState)!= RCC_CSI_OFF)
 80016a0:	69e2      	ldr	r2, [r4, #28]
 80016a2:	b36a      	cbz	r2, 8001700 <HAL_RCC_OscConfig+0x2a0>
        __HAL_RCC_CSI_ENABLE();
 80016a4:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 80016a6:	4d14      	ldr	r5, [pc, #80]	; (80016f8 <HAL_RCC_OscConfig+0x298>)
        __HAL_RCC_CSI_ENABLE();
 80016a8:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80016ac:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 80016ae:	f7ff fa47 	bl	8000b40 <HAL_GetTick>
 80016b2:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 80016b4:	682b      	ldr	r3, [r5, #0]
 80016b6:	05df      	lsls	r7, r3, #23
 80016b8:	d511      	bpl.n	80016de <HAL_RCC_OscConfig+0x27e>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 80016ba:	f7ff fa47 	bl	8000b4c <HAL_GetREVID>
 80016be:	f241 0303 	movw	r3, #4099	; 0x1003
 80016c2:	6a22      	ldr	r2, [r4, #32]
 80016c4:	4298      	cmp	r0, r3
 80016c6:	d810      	bhi.n	80016ea <HAL_RCC_OscConfig+0x28a>
 80016c8:	686b      	ldr	r3, [r5, #4]
 80016ca:	2a20      	cmp	r2, #32
 80016cc:	f023 43f8 	bic.w	r3, r3, #2080374784	; 0x7c000000
 80016d0:	bf0c      	ite	eq
 80016d2:	f043 4380 	orreq.w	r3, r3, #1073741824	; 0x40000000
 80016d6:	ea43 6382 	orrne.w	r3, r3, r2, lsl #26
 80016da:	606b      	str	r3, [r5, #4]
 80016dc:	e6f7      	b.n	80014ce <HAL_RCC_OscConfig+0x6e>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
 80016de:	f7ff fa2f 	bl	8000b40 <HAL_GetTick>
 80016e2:	1b80      	subs	r0, r0, r6
 80016e4:	2802      	cmp	r0, #2
 80016e6:	d9e5      	bls.n	80016b4 <HAL_RCC_OscConfig+0x254>
 80016e8:	e74a      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
        __HAL_RCC_CSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->CSICalibrationValue);
 80016ea:	68eb      	ldr	r3, [r5, #12]
 80016ec:	f023 537c 	bic.w	r3, r3, #1056964608	; 0x3f000000
 80016f0:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80016f4:	60eb      	str	r3, [r5, #12]
 80016f6:	e6ea      	b.n	80014ce <HAL_RCC_OscConfig+0x6e>
 80016f8:	58024400 	.word	0x58024400
 80016fc:	58024800 	.word	0x58024800
        __HAL_RCC_CSI_DISABLE();
 8001700:	681a      	ldr	r2, [r3, #0]
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8001702:	4e9f      	ldr	r6, [pc, #636]	; (8001980 <HAL_RCC_OscConfig+0x520>)
        __HAL_RCC_CSI_DISABLE();
 8001704:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001708:	601a      	str	r2, [r3, #0]
        tickstart = HAL_GetTick();
 800170a:	f7ff fa19 	bl	8000b40 <HAL_GetTick>
 800170e:	4605      	mov	r5, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) != 0U)
 8001710:	6833      	ldr	r3, [r6, #0]
 8001712:	05d8      	lsls	r0, r3, #23
 8001714:	f57f aedb 	bpl.w	80014ce <HAL_RCC_OscConfig+0x6e>
          if((HAL_GetTick() - tickstart ) > CSI_TIMEOUT_VALUE)
 8001718:	f7ff fa12 	bl	8000b40 <HAL_GetTick>
 800171c:	1b40      	subs	r0, r0, r5
 800171e:	2802      	cmp	r0, #2
 8001720:	d9f6      	bls.n	8001710 <HAL_RCC_OscConfig+0x2b0>
 8001722:	e72d      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
    if((RCC_OscInitStruct->LSIState)!= RCC_LSI_OFF)
 8001724:	6963      	ldr	r3, [r4, #20]
 8001726:	4d96      	ldr	r5, [pc, #600]	; (8001980 <HAL_RCC_OscConfig+0x520>)
 8001728:	b183      	cbz	r3, 800174c <HAL_RCC_OscConfig+0x2ec>
      __HAL_RCC_LSI_ENABLE();
 800172a:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800172c:	f043 0301 	orr.w	r3, r3, #1
 8001730:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
 8001732:	f7ff fa05 	bl	8000b40 <HAL_GetTick>
 8001736:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) == 0U)
 8001738:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800173a:	079b      	lsls	r3, r3, #30
 800173c:	f53f aecb 	bmi.w	80014d6 <HAL_RCC_OscConfig+0x76>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001740:	f7ff f9fe 	bl	8000b40 <HAL_GetTick>
 8001744:	1b80      	subs	r0, r0, r6
 8001746:	2802      	cmp	r0, #2
 8001748:	d9f6      	bls.n	8001738 <HAL_RCC_OscConfig+0x2d8>
 800174a:	e719      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
      __HAL_RCC_LSI_DISABLE();
 800174c:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800174e:	f023 0301 	bic.w	r3, r3, #1
 8001752:	676b      	str	r3, [r5, #116]	; 0x74
      tickstart = HAL_GetTick();
 8001754:	f7ff f9f4 	bl	8000b40 <HAL_GetTick>
 8001758:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSIRDY) != 0U)
 800175a:	6f6b      	ldr	r3, [r5, #116]	; 0x74
 800175c:	079f      	lsls	r7, r3, #30
 800175e:	f57f aeba 	bpl.w	80014d6 <HAL_RCC_OscConfig+0x76>
        if((HAL_GetTick() - tickstart ) > LSI_TIMEOUT_VALUE)
 8001762:	f7ff f9ed 	bl	8000b40 <HAL_GetTick>
 8001766:	1b80      	subs	r0, r0, r6
 8001768:	2802      	cmp	r0, #2
 800176a:	d9f6      	bls.n	800175a <HAL_RCC_OscConfig+0x2fa>
 800176c:	e708      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
    if((RCC_OscInitStruct->HSI48State)!= RCC_HSI48_OFF)
 800176e:	69a3      	ldr	r3, [r4, #24]
 8001770:	4d83      	ldr	r5, [pc, #524]	; (8001980 <HAL_RCC_OscConfig+0x520>)
 8001772:	b183      	cbz	r3, 8001796 <HAL_RCC_OscConfig+0x336>
      __HAL_RCC_HSI48_ENABLE();
 8001774:	682b      	ldr	r3, [r5, #0]
 8001776:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800177a:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 800177c:	f7ff f9e0 	bl	8000b40 <HAL_GetTick>
 8001780:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) == 0U)
 8001782:	682b      	ldr	r3, [r5, #0]
 8001784:	0498      	lsls	r0, r3, #18
 8001786:	f53f aeaa 	bmi.w	80014de <HAL_RCC_OscConfig+0x7e>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
 800178a:	f7ff f9d9 	bl	8000b40 <HAL_GetTick>
 800178e:	1b80      	subs	r0, r0, r6
 8001790:	2802      	cmp	r0, #2
 8001792:	d9f6      	bls.n	8001782 <HAL_RCC_OscConfig+0x322>
 8001794:	e6f4      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
      __HAL_RCC_HSI48_DISABLE();
 8001796:	682b      	ldr	r3, [r5, #0]
 8001798:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800179c:	602b      	str	r3, [r5, #0]
      tickstart = HAL_GetTick();
 800179e:	f7ff f9cf 	bl	8000b40 <HAL_GetTick>
 80017a2:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_HSI48RDY) != 0U)
 80017a4:	682b      	ldr	r3, [r5, #0]
 80017a6:	0499      	lsls	r1, r3, #18
 80017a8:	f57f ae99 	bpl.w	80014de <HAL_RCC_OscConfig+0x7e>
        if((HAL_GetTick() - tickstart ) > HSI48_TIMEOUT_VALUE)
 80017ac:	f7ff f9c8 	bl	8000b40 <HAL_GetTick>
 80017b0:	1b80      	subs	r0, r0, r6
 80017b2:	2802      	cmp	r0, #2
 80017b4:	d9f6      	bls.n	80017a4 <HAL_RCC_OscConfig+0x344>
 80017b6:	e6e3      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
      if((HAL_GetTick() - tickstart ) > RCC_DBP_TIMEOUT_VALUE)
 80017b8:	f7ff f9c2 	bl	8000b40 <HAL_GetTick>
 80017bc:	1b80      	subs	r0, r0, r6
 80017be:	2864      	cmp	r0, #100	; 0x64
 80017c0:	f67f ae98 	bls.w	80014f4 <HAL_RCC_OscConfig+0x94>
 80017c4:	e6dc      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80017c6:	b9b3      	cbnz	r3, 80017f6 <HAL_RCC_OscConfig+0x396>
 80017c8:	6f2b      	ldr	r3, [r5, #112]	; 0x70
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80017ca:	f241 3788 	movw	r7, #5000	; 0x1388
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80017ce:	f023 0301 	bic.w	r3, r3, #1
 80017d2:	672b      	str	r3, [r5, #112]	; 0x70
 80017d4:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80017d6:	f023 0304 	bic.w	r3, r3, #4
 80017da:	672b      	str	r3, [r5, #112]	; 0x70
      tickstart = HAL_GetTick();
 80017dc:	f7ff f9b0 	bl	8000b40 <HAL_GetTick>
 80017e0:	4606      	mov	r6, r0
      while(__HAL_RCC_GET_FLAG(RCC_FLAG_LSERDY) != 0U)
 80017e2:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80017e4:	0798      	lsls	r0, r3, #30
 80017e6:	f57f ae9c 	bpl.w	8001522 <HAL_RCC_OscConfig+0xc2>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 80017ea:	f7ff f9a9 	bl	8000b40 <HAL_GetTick>
 80017ee:	1b80      	subs	r0, r0, r6
 80017f0:	42b8      	cmp	r0, r7
 80017f2:	d9f6      	bls.n	80017e2 <HAL_RCC_OscConfig+0x382>
 80017f4:	e6c4      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80017f6:	2b05      	cmp	r3, #5
 80017f8:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 80017fa:	d103      	bne.n	8001804 <HAL_RCC_OscConfig+0x3a4>
 80017fc:	f043 0304 	orr.w	r3, r3, #4
 8001800:	672b      	str	r3, [r5, #112]	; 0x70
 8001802:	e680      	b.n	8001506 <HAL_RCC_OscConfig+0xa6>
 8001804:	f023 0301 	bic.w	r3, r3, #1
 8001808:	672b      	str	r3, [r5, #112]	; 0x70
 800180a:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 800180c:	f023 0304 	bic.w	r3, r3, #4
 8001810:	e67c      	b.n	800150c <HAL_RCC_OscConfig+0xac>
        if((HAL_GetTick() - tickstart ) > RCC_LSE_TIMEOUT_VALUE)
 8001812:	f7ff f995 	bl	8000b40 <HAL_GetTick>
 8001816:	1b40      	subs	r0, r0, r5
 8001818:	42b8      	cmp	r0, r7
 800181a:	f67f ae7e 	bls.w	800151a <HAL_RCC_OscConfig+0xba>
 800181e:	e6af      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL1)
 8001820:	4d57      	ldr	r5, [pc, #348]	; (8001980 <HAL_RCC_OscConfig+0x520>)
 8001822:	692b      	ldr	r3, [r5, #16]
 8001824:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8001828:	2b18      	cmp	r3, #24
 800182a:	d07a      	beq.n	8001922 <HAL_RCC_OscConfig+0x4c2>
        __HAL_RCC_PLL_DISABLE();
 800182c:	682b      	ldr	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 800182e:	2802      	cmp	r0, #2
        __HAL_RCC_PLL_DISABLE();
 8001830:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8001834:	602b      	str	r3, [r5, #0]
      if((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_ON)
 8001836:	d167      	bne.n	8001908 <HAL_RCC_OscConfig+0x4a8>
        tickstart = HAL_GetTick();
 8001838:	f7ff f982 	bl	8000b40 <HAL_GetTick>
 800183c:	4606      	mov	r6, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800183e:	682b      	ldr	r3, [r5, #0]
 8001840:	0199      	lsls	r1, r3, #6
 8001842:	d45b      	bmi.n	80018fc <HAL_RCC_OscConfig+0x49c>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8001844:	6aab      	ldr	r3, [r5, #40]	; 0x28
 8001846:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001848:	f423 737c 	bic.w	r3, r3, #1008	; 0x3f0
 800184c:	f023 0303 	bic.w	r3, r3, #3
 8001850:	4313      	orrs	r3, r2
 8001852:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 8001854:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 8001858:	62ab      	str	r3, [r5, #40]	; 0x28
 800185a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800185c:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800185e:	3b01      	subs	r3, #1
 8001860:	3a01      	subs	r2, #1
 8001862:	025b      	lsls	r3, r3, #9
 8001864:	0412      	lsls	r2, r2, #16
 8001866:	b29b      	uxth	r3, r3
 8001868:	f402 02fe 	and.w	r2, r2, #8323072	; 0x7f0000
 800186c:	4313      	orrs	r3, r2
 800186e:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8001870:	3a01      	subs	r2, #1
 8001872:	f3c2 0208 	ubfx	r2, r2, #0, #9
 8001876:	4313      	orrs	r3, r2
 8001878:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 800187a:	3a01      	subs	r2, #1
 800187c:	0612      	lsls	r2, r2, #24
 800187e:	f002 42fe 	and.w	r2, r2, #2130706432	; 0x7f000000
 8001882:	4313      	orrs	r3, r2
 8001884:	632b      	str	r3, [r5, #48]	; 0x30
         __HAL_RCC_PLLFRACN_DISABLE();
 8001886:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 8001888:	f023 0301 	bic.w	r3, r3, #1
 800188c:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_CONFIG(RCC_OscInitStruct->PLL.PLLFRACN);
 800188e:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8001890:	6ca2      	ldr	r2, [r4, #72]	; 0x48
 8001892:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8001896:	f023 03f8 	bic.w	r3, r3, #248	; 0xf8
 800189a:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800189e:	636b      	str	r3, [r5, #52]	; 0x34
        __HAL_RCC_PLL_VCIRANGE(RCC_OscInitStruct->PLL.PLLRGE) ;
 80018a0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80018a2:	6c22      	ldr	r2, [r4, #64]	; 0x40
 80018a4:	f023 030c 	bic.w	r3, r3, #12
 80018a8:	4313      	orrs	r3, r2
 80018aa:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_VCORANGE(RCC_OscInitStruct->PLL.PLLVCOSEL) ;
 80018ac:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80018ae:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80018b0:	f023 0302 	bic.w	r3, r3, #2
 80018b4:	4313      	orrs	r3, r2
 80018b6:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVP);
 80018b8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80018ba:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80018be:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVQ);
 80018c0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80018c2:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80018c6:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL1_DIVR);
 80018c8:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80018ca:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 80018ce:	62eb      	str	r3, [r5, #44]	; 0x2c
         __HAL_RCC_PLLFRACN_ENABLE();
 80018d0:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 80018d2:	f043 0301 	orr.w	r3, r3, #1
 80018d6:	62eb      	str	r3, [r5, #44]	; 0x2c
        __HAL_RCC_PLL_ENABLE();
 80018d8:	682b      	ldr	r3, [r5, #0]
 80018da:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80018de:	602b      	str	r3, [r5, #0]
        tickstart = HAL_GetTick();
 80018e0:	f7ff f92e 	bl	8000b40 <HAL_GetTick>
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80018e4:	4d26      	ldr	r5, [pc, #152]	; (8001980 <HAL_RCC_OscConfig+0x520>)
        tickstart = HAL_GetTick();
 80018e6:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 80018e8:	682b      	ldr	r3, [r5, #0]
 80018ea:	019a      	lsls	r2, r3, #6
 80018ec:	f53f ae1d 	bmi.w	800152a <HAL_RCC_OscConfig+0xca>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80018f0:	f7ff f926 	bl	8000b40 <HAL_GetTick>
 80018f4:	1b00      	subs	r0, r0, r4
 80018f6:	2802      	cmp	r0, #2
 80018f8:	d9f6      	bls.n	80018e8 <HAL_RCC_OscConfig+0x488>
 80018fa:	e641      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 80018fc:	f7ff f920 	bl	8000b40 <HAL_GetTick>
 8001900:	1b80      	subs	r0, r0, r6
 8001902:	2802      	cmp	r0, #2
 8001904:	d99b      	bls.n	800183e <HAL_RCC_OscConfig+0x3de>
 8001906:	e63b      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
        tickstart = HAL_GetTick();
 8001908:	f7ff f91a 	bl	8000b40 <HAL_GetTick>
 800190c:	4604      	mov	r4, r0
        while(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) != 0U)
 800190e:	682b      	ldr	r3, [r5, #0]
 8001910:	019b      	lsls	r3, r3, #6
 8001912:	f57f ae0a 	bpl.w	800152a <HAL_RCC_OscConfig+0xca>
          if((HAL_GetTick() - tickstart ) > PLL_TIMEOUT_VALUE)
 8001916:	f7ff f913 	bl	8000b40 <HAL_GetTick>
 800191a:	1b00      	subs	r0, r0, r4
 800191c:	2802      	cmp	r0, #2
 800191e:	d9f6      	bls.n	800190e <HAL_RCC_OscConfig+0x4ae>
 8001920:	e62e      	b.n	8001580 <HAL_RCC_OscConfig+0x120>
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8001922:	2801      	cmp	r0, #1
      temp1_pllckcfg = RCC->PLLCKSELR;
 8001924:	6aaa      	ldr	r2, [r5, #40]	; 0x28
      temp2_pllckcfg = RCC->PLL1DIVR;
 8001926:	6b2b      	ldr	r3, [r5, #48]	; 0x30
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8001928:	f43f ae2b 	beq.w	8001582 <HAL_RCC_OscConfig+0x122>
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800192c:	f002 0103 	and.w	r1, r2, #3
      if(((RCC_OscInitStruct->PLL.PLLState) == RCC_PLL_OFF) ||
 8001930:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 8001932:	4281      	cmp	r1, r0
 8001934:	f47f ad97 	bne.w	8001466 <HAL_RCC_OscConfig+0x6>
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 8001938:	f3c2 1205 	ubfx	r2, r2, #4, #6
	 (READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_PLLSRC) != RCC_OscInitStruct->PLL.PLLSource) ||
 800193c:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 800193e:	428a      	cmp	r2, r1
 8001940:	f47f ad91 	bne.w	8001466 <HAL_RCC_OscConfig+0x6>
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 8001944:	6b22      	ldr	r2, [r4, #48]	; 0x30
 8001946:	f3c3 0108 	ubfx	r1, r3, #0, #9
 800194a:	3a01      	subs	r2, #1
         ((READ_BIT(temp1_pllckcfg, RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos) != RCC_OscInitStruct->PLL.PLLM) ||
 800194c:	4291      	cmp	r1, r2
 800194e:	f47f ad8a 	bne.w	8001466 <HAL_RCC_OscConfig+0x6>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 8001952:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8001954:	f3c3 2146 	ubfx	r1, r3, #9, #7
 8001958:	3a01      	subs	r2, #1
         (READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_N1) != (RCC_OscInitStruct->PLL.PLLN - 1U)) ||
 800195a:	4291      	cmp	r1, r2
 800195c:	f47f ad83 	bne.w	8001466 <HAL_RCC_OscConfig+0x6>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_Q1) >> RCC_PLL1DIVR_Q1_Pos) != (RCC_OscInitStruct->PLL.PLLQ - 1U)) ||
 8001960:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001962:	f3c3 4106 	ubfx	r1, r3, #16, #7
 8001966:	3a01      	subs	r2, #1
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_P1) >> RCC_PLL1DIVR_P1_Pos) != (RCC_OscInitStruct->PLL.PLLP - 1U)) ||
 8001968:	4291      	cmp	r1, r2
 800196a:	f47f ad7c 	bne.w	8001466 <HAL_RCC_OscConfig+0x6>
         ((READ_BIT(temp2_pllckcfg, RCC_PLL1DIVR_R1) >> RCC_PLL1DIVR_R1_Pos) != (RCC_OscInitStruct->PLL.PLLR - 1U)))
 800196e:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8001970:	f3c3 6306 	ubfx	r3, r3, #24, #7
 8001974:	3801      	subs	r0, #1
  return HAL_OK;
 8001976:	1a18      	subs	r0, r3, r0
 8001978:	bf18      	it	ne
 800197a:	2001      	movne	r0, #1
 800197c:	e601      	b.n	8001582 <HAL_RCC_OscConfig+0x122>
 800197e:	bf00      	nop
 8001980:	58024400 	.word	0x58024400

08001984 <HAL_RCC_GetSysClockFreq>:
  float_t fracn1, pllvco;
  uint32_t sysclockfreq;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001984:	4b48      	ldr	r3, [pc, #288]	; (8001aa8 <HAL_RCC_GetSysClockFreq+0x124>)
 8001986:	691a      	ldr	r2, [r3, #16]
 8001988:	f002 0238 	and.w	r2, r2, #56	; 0x38
 800198c:	2a10      	cmp	r2, #16
{
 800198e:	b530      	push	{r4, r5, lr}
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001990:	f000 8086 	beq.w	8001aa0 <HAL_RCC_GetSysClockFreq+0x11c>
 8001994:	2a18      	cmp	r2, #24
 8001996:	d00c      	beq.n	80019b2 <HAL_RCC_GetSysClockFreq+0x2e>
 8001998:	2a00      	cmp	r2, #0
 800199a:	f040 8083 	bne.w	8001aa4 <HAL_RCC_GetSysClockFreq+0x120>
  {
  case RCC_CFGR_SWS_HSI:  /* HSI used as system clock source */

   if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 800199e:	681a      	ldr	r2, [r3, #0]
 80019a0:	4842      	ldr	r0, [pc, #264]	; (8001aac <HAL_RCC_GetSysClockFreq+0x128>)
 80019a2:	f012 0f20 	tst.w	r2, #32
 80019a6:	d003      	beq.n	80019b0 <HAL_RCC_GetSysClockFreq+0x2c>
      {
        sysclockfreq = (uint32_t) (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 80019a8:	681b      	ldr	r3, [r3, #0]
 80019aa:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 80019ae:	40d8      	lsrs	r0, r3
    sysclockfreq = CSI_VALUE;
    break;
  }

  return sysclockfreq;
}
 80019b0:	bd30      	pop	{r4, r5, pc}
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 80019b2:	6a99      	ldr	r1, [r3, #40]	; 0x28
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 80019b4:	6a9d      	ldr	r5, [r3, #40]	; 0x28
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 80019b6:	6adc      	ldr	r4, [r3, #44]	; 0x2c
    if (pllm != 0U)
 80019b8:	f415 7f7c 	tst.w	r5, #1008	; 0x3f0
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1)>> 4)  ;
 80019bc:	f3c5 1005 	ubfx	r0, r5, #4, #6
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 80019c0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
    if (pllm != 0U)
 80019c2:	d0f5      	beq.n	80019b0 <HAL_RCC_GetSysClockFreq+0x2c>
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 80019c4:	f3c2 02cc 	ubfx	r2, r2, #3, #13
    pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN)>>RCC_PLLCFGR_PLL1FRACEN_Pos);
 80019c8:	f004 0401 	and.w	r4, r4, #1
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 80019cc:	ee07 0a90 	vmov	s15, r0
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
 80019d0:	f001 0103 	and.w	r1, r1, #3
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 80019d4:	4362      	muls	r2, r4
 80019d6:	eeb7 6a00 	vmov.f32	s12, #112	; 0x3f800000  1.0
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 80019da:	eef8 6ae7 	vcvt.f32.s32	s13, s15
 80019de:	2901      	cmp	r1, #1
    fracn1 = (float_t)(uint32_t)(pllfracen* ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN1)>> 3));
 80019e0:	ee07 2a90 	vmov	s15, r2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 80019e4:	eefa 7ae9 	vcvt.f32.s32	s15, s15, #13
 80019e8:	d04c      	beq.n	8001a84 <HAL_RCC_GetSysClockFreq+0x100>
 80019ea:	2902      	cmp	r1, #2
 80019ec:	d03c      	beq.n	8001a68 <HAL_RCC_GetSysClockFreq+0xe4>
 80019ee:	2900      	cmp	r1, #0
 80019f0:	d148      	bne.n	8001a84 <HAL_RCC_GetSysClockFreq+0x100>
       if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
 80019f2:	681a      	ldr	r2, [r3, #0]
 80019f4:	0692      	lsls	r2, r2, #26
 80019f6:	d527      	bpl.n	8001a48 <HAL_RCC_GetSysClockFreq+0xc4>
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 80019f8:	6819      	ldr	r1, [r3, #0]
 80019fa:	4a2c      	ldr	r2, [pc, #176]	; (8001aac <HAL_RCC_GetSysClockFreq+0x128>)
 80019fc:	f3c1 01c1 	ubfx	r1, r1, #3, #2
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8001a00:	6b1b      	ldr	r3, [r3, #48]	; 0x30
          hsivalue= (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER()>> 3));
 8001a02:	40ca      	lsrs	r2, r1
          pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8001a04:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001a08:	ee07 2a10 	vmov	s14, r2
 8001a0c:	eef8 5ac7 	vcvt.f32.s32	s11, s14
 8001a10:	ee85 7aa6 	vdiv.f32	s14, s11, s13
 8001a14:	ee06 3a90 	vmov	s13, r3
 8001a18:	eef8 6ae6 	vcvt.f32.s32	s13, s13
 8001a1c:	ee76 7aa7 	vadd.f32	s15, s13, s15
 8001a20:	ee77 7a86 	vadd.f32	s15, s15, s12
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
 8001a24:	4b20      	ldr	r3, [pc, #128]	; (8001aa8 <HAL_RCC_GetSysClockFreq+0x124>)
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8001a26:	ee67 7a87 	vmul.f32	s15, s15, s14
      pllp = (((RCC->PLL1DIVR & RCC_PLL1DIVR_P1) >>9) + 1U ) ;
 8001a2a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001a2c:	f3c3 2346 	ubfx	r3, r3, #9, #7
 8001a30:	3301      	adds	r3, #1
      sysclockfreq =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
 8001a32:	ee07 3a10 	vmov	s14, r3
 8001a36:	eef8 6ac7 	vcvt.f32.s32	s13, s14
 8001a3a:	ee87 7aa6 	vdiv.f32	s14, s15, s13
 8001a3e:	eefc 7ac7 	vcvt.u32.f32	s15, s14
 8001a42:	ee17 0a90 	vmov	r0, s15
 8001a46:	e7b3      	b.n	80019b0 <HAL_RCC_GetSysClockFreq+0x2c>
          pllvco = ((float_t)HSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8001a48:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001a4a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001a4e:	ee07 3a10 	vmov	s14, r3
 8001a52:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8001a56:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001a5a:	ee77 7a86 	vadd.f32	s15, s15, s12
 8001a5e:	ed9f 6a14 	vldr	s12, [pc, #80]	; 8001ab0 <HAL_RCC_GetSysClockFreq+0x12c>
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8001a62:	ee86 7a26 	vdiv.f32	s14, s12, s13
 8001a66:	e7dd      	b.n	8001a24 <HAL_RCC_GetSysClockFreq+0xa0>
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8001a68:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001a6a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001a6e:	ee07 3a10 	vmov	s14, r3
 8001a72:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8001a76:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001a7a:	ee77 7a86 	vadd.f32	s15, s15, s12
 8001a7e:	ed9f 6a0d 	vldr	s12, [pc, #52]	; 8001ab4 <HAL_RCC_GetSysClockFreq+0x130>
 8001a82:	e7ee      	b.n	8001a62 <HAL_RCC_GetSysClockFreq+0xde>
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR & RCC_PLL1DIVR_N1) + (fracn1/(float_t)0x2000) +(float_t)1 );
 8001a84:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001a86:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8001a8a:	ee07 3a10 	vmov	s14, r3
 8001a8e:	eeb8 7ac7 	vcvt.f32.s32	s14, s14
 8001a92:	ee77 7a27 	vadd.f32	s15, s14, s15
 8001a96:	ee77 7a86 	vadd.f32	s15, s15, s12
 8001a9a:	ed9f 6a07 	vldr	s12, [pc, #28]	; 8001ab8 <HAL_RCC_GetSysClockFreq+0x134>
 8001a9e:	e7e0      	b.n	8001a62 <HAL_RCC_GetSysClockFreq+0xde>
  switch (RCC->CFGR & RCC_CFGR_SWS)
 8001aa0:	4806      	ldr	r0, [pc, #24]	; (8001abc <HAL_RCC_GetSysClockFreq+0x138>)
 8001aa2:	e785      	b.n	80019b0 <HAL_RCC_GetSysClockFreq+0x2c>
    sysclockfreq = CSI_VALUE;
 8001aa4:	4806      	ldr	r0, [pc, #24]	; (8001ac0 <HAL_RCC_GetSysClockFreq+0x13c>)
 8001aa6:	e783      	b.n	80019b0 <HAL_RCC_GetSysClockFreq+0x2c>
 8001aa8:	58024400 	.word	0x58024400
 8001aac:	03d09000 	.word	0x03d09000
 8001ab0:	4c742400 	.word	0x4c742400
 8001ab4:	4bbebc20 	.word	0x4bbebc20
 8001ab8:	4a742400 	.word	0x4a742400
 8001abc:	017d7840 	.word	0x017d7840
 8001ac0:	003d0900 	.word	0x003d0900

08001ac4 <HAL_RCC_ClockConfig>:
{
 8001ac4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001ac8:	460d      	mov	r5, r1
  if(RCC_ClkInitStruct == NULL)
 8001aca:	4604      	mov	r4, r0
 8001acc:	b910      	cbnz	r0, 8001ad4 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 8001ace:	2001      	movs	r0, #1
}
 8001ad0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8001ad4:	4a88      	ldr	r2, [pc, #544]	; (8001cf8 <HAL_RCC_ClockConfig+0x234>)
 8001ad6:	6813      	ldr	r3, [r2, #0]
 8001ad8:	f003 030f 	and.w	r3, r3, #15
 8001adc:	428b      	cmp	r3, r1
 8001ade:	f0c0 8093 	bcc.w	8001c08 <HAL_RCC_ClockConfig+0x144>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 8001ae2:	6823      	ldr	r3, [r4, #0]
 8001ae4:	075f      	lsls	r7, r3, #29
 8001ae6:	f100 809b 	bmi.w	8001c20 <HAL_RCC_ClockConfig+0x15c>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001aea:	071e      	lsls	r6, r3, #28
 8001aec:	d50b      	bpl.n	8001b06 <HAL_RCC_ClockConfig+0x42>
    if((RCC_ClkInitStruct->APB1CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 8001aee:	4983      	ldr	r1, [pc, #524]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
 8001af0:	6966      	ldr	r6, [r4, #20]
 8001af2:	69c8      	ldr	r0, [r1, #28]
 8001af4:	f000 0070 	and.w	r0, r0, #112	; 0x70
 8001af8:	4286      	cmp	r6, r0
 8001afa:	d904      	bls.n	8001b06 <HAL_RCC_ClockConfig+0x42>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 8001afc:	69ca      	ldr	r2, [r1, #28]
 8001afe:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001b02:	4332      	orrs	r2, r6
 8001b04:	61ca      	str	r2, [r1, #28]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001b06:	06d8      	lsls	r0, r3, #27
 8001b08:	d50b      	bpl.n	8001b22 <HAL_RCC_ClockConfig+0x5e>
    if((RCC_ClkInitStruct->APB2CLKDivider) > (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8001b0a:	497c      	ldr	r1, [pc, #496]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
 8001b0c:	69a6      	ldr	r6, [r4, #24]
 8001b0e:	69c8      	ldr	r0, [r1, #28]
 8001b10:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8001b14:	4286      	cmp	r6, r0
 8001b16:	d904      	bls.n	8001b22 <HAL_RCC_ClockConfig+0x5e>
      MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 8001b18:	69ca      	ldr	r2, [r1, #28]
 8001b1a:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8001b1e:	4332      	orrs	r2, r6
 8001b20:	61ca      	str	r2, [r1, #28]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 8001b22:	0699      	lsls	r1, r3, #26
 8001b24:	d50b      	bpl.n	8001b3e <HAL_RCC_ClockConfig+0x7a>
    if((RCC_ClkInitStruct->APB4CLKDivider) > (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 8001b26:	4975      	ldr	r1, [pc, #468]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
 8001b28:	69e6      	ldr	r6, [r4, #28]
 8001b2a:	6a08      	ldr	r0, [r1, #32]
 8001b2c:	f000 0070 	and.w	r0, r0, #112	; 0x70
 8001b30:	4286      	cmp	r6, r0
 8001b32:	d904      	bls.n	8001b3e <HAL_RCC_ClockConfig+0x7a>
      MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
 8001b34:	6a0a      	ldr	r2, [r1, #32]
 8001b36:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001b3a:	4332      	orrs	r2, r6
 8001b3c:	620a      	str	r2, [r1, #32]
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001b3e:	079a      	lsls	r2, r3, #30
 8001b40:	d50b      	bpl.n	8001b5a <HAL_RCC_ClockConfig+0x96>
    if((RCC_ClkInitStruct->AHBCLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 8001b42:	496e      	ldr	r1, [pc, #440]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
 8001b44:	68e6      	ldr	r6, [r4, #12]
 8001b46:	6988      	ldr	r0, [r1, #24]
 8001b48:	f000 000f 	and.w	r0, r0, #15
 8001b4c:	4286      	cmp	r6, r0
 8001b4e:	d904      	bls.n	8001b5a <HAL_RCC_ClockConfig+0x96>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001b50:	698a      	ldr	r2, [r1, #24]
 8001b52:	f022 020f 	bic.w	r2, r2, #15
 8001b56:	4332      	orrs	r2, r6
 8001b58:	618a      	str	r2, [r1, #24]
    if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8001b5a:	07df      	lsls	r7, r3, #31
 8001b5c:	d46e      	bmi.n	8001c3c <HAL_RCC_ClockConfig+0x178>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 8001b5e:	6823      	ldr	r3, [r4, #0]
 8001b60:	079e      	lsls	r6, r3, #30
 8001b62:	f100 80a1 	bmi.w	8001ca8 <HAL_RCC_ClockConfig+0x1e4>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8001b66:	4964      	ldr	r1, [pc, #400]	; (8001cf8 <HAL_RCC_ClockConfig+0x234>)
 8001b68:	680a      	ldr	r2, [r1, #0]
 8001b6a:	f002 020f 	and.w	r2, r2, #15
 8001b6e:	42aa      	cmp	r2, r5
 8001b70:	f200 80a8 	bhi.w	8001cc4 <HAL_RCC_ClockConfig+0x200>
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D1PCLK1) == RCC_CLOCKTYPE_D1PCLK1)
 8001b74:	0758      	lsls	r0, r3, #29
 8001b76:	f100 80b1 	bmi.w	8001cdc <HAL_RCC_ClockConfig+0x218>
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8001b7a:	0719      	lsls	r1, r3, #28
 8001b7c:	d50b      	bpl.n	8001b96 <HAL_RCC_ClockConfig+0xd2>
   if((RCC_ClkInitStruct->APB1CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE1))
 8001b7e:	495f      	ldr	r1, [pc, #380]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
 8001b80:	6965      	ldr	r5, [r4, #20]
 8001b82:	69c8      	ldr	r0, [r1, #28]
 8001b84:	f000 0070 	and.w	r0, r0, #112	; 0x70
 8001b88:	4285      	cmp	r5, r0
 8001b8a:	d204      	bcs.n	8001b96 <HAL_RCC_ClockConfig+0xd2>
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE1, (RCC_ClkInitStruct->APB1CLKDivider));
 8001b8c:	69ca      	ldr	r2, [r1, #28]
 8001b8e:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001b92:	432a      	orrs	r2, r5
 8001b94:	61ca      	str	r2, [r1, #28]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8001b96:	06da      	lsls	r2, r3, #27
 8001b98:	d50b      	bpl.n	8001bb2 <HAL_RCC_ClockConfig+0xee>
   if((RCC_ClkInitStruct->APB2CLKDivider) < (RCC->D2CFGR & RCC_D2CFGR_D2PPRE2))
 8001b9a:	4958      	ldr	r1, [pc, #352]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
 8001b9c:	69a5      	ldr	r5, [r4, #24]
 8001b9e:	69c8      	ldr	r0, [r1, #28]
 8001ba0:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
 8001ba4:	4285      	cmp	r5, r0
 8001ba6:	d204      	bcs.n	8001bb2 <HAL_RCC_ClockConfig+0xee>
     MODIFY_REG(RCC->D2CFGR, RCC_D2CFGR_D2PPRE2, (RCC_ClkInitStruct->APB2CLKDivider));
 8001ba8:	69ca      	ldr	r2, [r1, #28]
 8001baa:	f422 62e0 	bic.w	r2, r2, #1792	; 0x700
 8001bae:	432a      	orrs	r2, r5
 8001bb0:	61ca      	str	r2, [r1, #28]
 if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_D3PCLK1) == RCC_CLOCKTYPE_D3PCLK1)
 8001bb2:	069b      	lsls	r3, r3, #26
 8001bb4:	d50b      	bpl.n	8001bce <HAL_RCC_ClockConfig+0x10a>
   if((RCC_ClkInitStruct->APB4CLKDivider) < (RCC->D3CFGR & RCC_D3CFGR_D3PPRE))
 8001bb6:	4a51      	ldr	r2, [pc, #324]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
 8001bb8:	69e0      	ldr	r0, [r4, #28]
 8001bba:	6a11      	ldr	r1, [r2, #32]
 8001bbc:	f001 0170 	and.w	r1, r1, #112	; 0x70
 8001bc0:	4288      	cmp	r0, r1
 8001bc2:	d204      	bcs.n	8001bce <HAL_RCC_ClockConfig+0x10a>
     MODIFY_REG(RCC->D3CFGR, RCC_D3CFGR_D3PPRE, (RCC_ClkInitStruct->APB4CLKDivider) );
 8001bc4:	6a13      	ldr	r3, [r2, #32]
 8001bc6:	f023 0370 	bic.w	r3, r3, #112	; 0x70
 8001bca:	4303      	orrs	r3, r0
 8001bcc:	6213      	str	r3, [r2, #32]
  common_system_clock = HAL_RCC_GetSysClockFreq() >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_D1CPRE)>> RCC_D1CFGR_D1CPRE_Pos]) & 0x1FU);
 8001bce:	f7ff fed9 	bl	8001984 <HAL_RCC_GetSysClockFreq>
 8001bd2:	494a      	ldr	r1, [pc, #296]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
 8001bd4:	4a4a      	ldr	r2, [pc, #296]	; (8001d00 <HAL_RCC_ClockConfig+0x23c>)
 8001bd6:	698b      	ldr	r3, [r1, #24]
 8001bd8:	f3c3 2303 	ubfx	r3, r3, #8, #4
 8001bdc:	5cd3      	ldrb	r3, [r2, r3]
 8001bde:	f003 031f 	and.w	r3, r3, #31
 8001be2:	40d8      	lsrs	r0, r3
  SystemD2Clock = (common_system_clock >> ((D1CorePrescTable[(RCC->D1CFGR & RCC_D1CFGR_HPRE)>> RCC_D1CFGR_HPRE_Pos]) & 0x1FU));
 8001be4:	698b      	ldr	r3, [r1, #24]
 8001be6:	f003 030f 	and.w	r3, r3, #15
 8001bea:	5cd3      	ldrb	r3, [r2, r3]
 8001bec:	4a45      	ldr	r2, [pc, #276]	; (8001d04 <HAL_RCC_ClockConfig+0x240>)
 8001bee:	f003 031f 	and.w	r3, r3, #31
 8001bf2:	fa20 f303 	lsr.w	r3, r0, r3
 8001bf6:	6013      	str	r3, [r2, #0]
  SystemCoreClock = common_system_clock;
 8001bf8:	4b43      	ldr	r3, [pc, #268]	; (8001d08 <HAL_RCC_ClockConfig+0x244>)
 8001bfa:	6018      	str	r0, [r3, #0]
  halstatus = HAL_InitTick (uwTickPrio);
 8001bfc:	4b43      	ldr	r3, [pc, #268]	; (8001d0c <HAL_RCC_ClockConfig+0x248>)
}
 8001bfe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  halstatus = HAL_InitTick (uwTickPrio);
 8001c02:	6818      	ldr	r0, [r3, #0]
 8001c04:	f7fe bf3e 	b.w	8000a84 <HAL_InitTick>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001c08:	6813      	ldr	r3, [r2, #0]
 8001c0a:	f023 030f 	bic.w	r3, r3, #15
 8001c0e:	430b      	orrs	r3, r1
 8001c10:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8001c12:	6813      	ldr	r3, [r2, #0]
 8001c14:	f003 030f 	and.w	r3, r3, #15
 8001c18:	428b      	cmp	r3, r1
 8001c1a:	f47f af58 	bne.w	8001ace <HAL_RCC_ClockConfig+0xa>
 8001c1e:	e760      	b.n	8001ae2 <HAL_RCC_ClockConfig+0x1e>
    if((RCC_ClkInitStruct->APB3CLKDivider) > (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 8001c20:	4936      	ldr	r1, [pc, #216]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
 8001c22:	6926      	ldr	r6, [r4, #16]
 8001c24:	6988      	ldr	r0, [r1, #24]
 8001c26:	f000 0070 	and.w	r0, r0, #112	; 0x70
 8001c2a:	4286      	cmp	r6, r0
 8001c2c:	f67f af5d 	bls.w	8001aea <HAL_RCC_ClockConfig+0x26>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 8001c30:	698a      	ldr	r2, [r1, #24]
 8001c32:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001c36:	4332      	orrs	r2, r6
 8001c38:	618a      	str	r2, [r1, #24]
 8001c3a:	e756      	b.n	8001aea <HAL_RCC_ClockConfig+0x26>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1CPRE, RCC_ClkInitStruct->SYSCLKDivider);
 8001c3c:	4b2f      	ldr	r3, [pc, #188]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
 8001c3e:	68a1      	ldr	r1, [r4, #8]
 8001c40:	699a      	ldr	r2, [r3, #24]
 8001c42:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00
 8001c46:	430a      	orrs	r2, r1
 8001c48:	619a      	str	r2, [r3, #24]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001c4a:	6862      	ldr	r2, [r4, #4]
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8001c4c:	681b      	ldr	r3, [r3, #0]
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8001c4e:	2a02      	cmp	r2, #2
 8001c50:	d11d      	bne.n	8001c8e <HAL_RCC_ClockConfig+0x1ca>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSERDY) == 0U)
 8001c52:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8001c56:	f43f af3a 	beq.w	8001ace <HAL_RCC_ClockConfig+0xa>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8001c5a:	4e28      	ldr	r6, [pc, #160]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001c5c:	f241 3888 	movw	r8, #5000	; 0x1388
      MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8001c60:	6933      	ldr	r3, [r6, #16]
 8001c62:	f023 0307 	bic.w	r3, r3, #7
 8001c66:	4313      	orrs	r3, r2
 8001c68:	6133      	str	r3, [r6, #16]
      tickstart = HAL_GetTick();
 8001c6a:	f7fe ff69 	bl	8000b40 <HAL_GetTick>
 8001c6e:	4607      	mov	r7, r0
        while (__HAL_RCC_GET_SYSCLK_SOURCE() !=  (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 8001c70:	6933      	ldr	r3, [r6, #16]
 8001c72:	6862      	ldr	r2, [r4, #4]
 8001c74:	f003 0338 	and.w	r3, r3, #56	; 0x38
 8001c78:	ebb3 0fc2 	cmp.w	r3, r2, lsl #3
 8001c7c:	f43f af6f 	beq.w	8001b5e <HAL_RCC_ClockConfig+0x9a>
          if((HAL_GetTick() - tickstart ) > CLOCKSWITCH_TIMEOUT_VALUE)
 8001c80:	f7fe ff5e 	bl	8000b40 <HAL_GetTick>
 8001c84:	1bc0      	subs	r0, r0, r7
 8001c86:	4540      	cmp	r0, r8
 8001c88:	d9f2      	bls.n	8001c70 <HAL_RCC_ClockConfig+0x1ac>
            return HAL_TIMEOUT;
 8001c8a:	2003      	movs	r0, #3
 8001c8c:	e720      	b.n	8001ad0 <HAL_RCC_ClockConfig+0xc>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 8001c8e:	2a03      	cmp	r2, #3
 8001c90:	d102      	bne.n	8001c98 <HAL_RCC_ClockConfig+0x1d4>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_PLLRDY) == 0U)
 8001c92:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
 8001c96:	e7de      	b.n	8001c56 <HAL_RCC_ClockConfig+0x192>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_CSI)
 8001c98:	2a01      	cmp	r2, #1
 8001c9a:	d102      	bne.n	8001ca2 <HAL_RCC_ClockConfig+0x1de>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_CSIRDY) == 0U)
 8001c9c:	f413 7f80 	tst.w	r3, #256	; 0x100
 8001ca0:	e7d9      	b.n	8001c56 <HAL_RCC_ClockConfig+0x192>
        if(__HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == 0U)
 8001ca2:	f013 0f04 	tst.w	r3, #4
 8001ca6:	e7d6      	b.n	8001c56 <HAL_RCC_ClockConfig+0x192>
    if((RCC_ClkInitStruct->AHBCLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_HPRE))
 8001ca8:	4914      	ldr	r1, [pc, #80]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
 8001caa:	68e6      	ldr	r6, [r4, #12]
 8001cac:	6988      	ldr	r0, [r1, #24]
 8001cae:	f000 000f 	and.w	r0, r0, #15
 8001cb2:	4286      	cmp	r6, r0
 8001cb4:	f4bf af57 	bcs.w	8001b66 <HAL_RCC_ClockConfig+0xa2>
      MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8001cb8:	698a      	ldr	r2, [r1, #24]
 8001cba:	f022 020f 	bic.w	r2, r2, #15
 8001cbe:	4332      	orrs	r2, r6
 8001cc0:	618a      	str	r2, [r1, #24]
 8001cc2:	e750      	b.n	8001b66 <HAL_RCC_ClockConfig+0xa2>
    __HAL_FLASH_SET_LATENCY(FLatency);
 8001cc4:	680a      	ldr	r2, [r1, #0]
 8001cc6:	f022 020f 	bic.w	r2, r2, #15
 8001cca:	432a      	orrs	r2, r5
 8001ccc:	600a      	str	r2, [r1, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8001cce:	680a      	ldr	r2, [r1, #0]
 8001cd0:	f002 020f 	and.w	r2, r2, #15
 8001cd4:	42aa      	cmp	r2, r5
 8001cd6:	f47f aefa 	bne.w	8001ace <HAL_RCC_ClockConfig+0xa>
 8001cda:	e74b      	b.n	8001b74 <HAL_RCC_ClockConfig+0xb0>
   if((RCC_ClkInitStruct->APB3CLKDivider) < (RCC->D1CFGR & RCC_D1CFGR_D1PPRE))
 8001cdc:	4907      	ldr	r1, [pc, #28]	; (8001cfc <HAL_RCC_ClockConfig+0x238>)
 8001cde:	6925      	ldr	r5, [r4, #16]
 8001ce0:	6988      	ldr	r0, [r1, #24]
 8001ce2:	f000 0070 	and.w	r0, r0, #112	; 0x70
 8001ce6:	4285      	cmp	r5, r0
 8001ce8:	f4bf af47 	bcs.w	8001b7a <HAL_RCC_ClockConfig+0xb6>
     MODIFY_REG(RCC->D1CFGR, RCC_D1CFGR_D1PPRE, RCC_ClkInitStruct->APB3CLKDivider);
 8001cec:	698a      	ldr	r2, [r1, #24]
 8001cee:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 8001cf2:	432a      	orrs	r2, r5
 8001cf4:	618a      	str	r2, [r1, #24]
 8001cf6:	e740      	b.n	8001b7a <HAL_RCC_ClockConfig+0xb6>
 8001cf8:	52002000 	.word	0x52002000
 8001cfc:	58024400 	.word	0x58024400
 8001d00:	08001d70 	.word	0x08001d70
 8001d04:	20000004 	.word	0x20000004
 8001d08:	20000000 	.word	0x20000000
 8001d0c:	2000000c 	.word	0x2000000c

08001d10 <__libc_init_array>:
 8001d10:	b570      	push	{r4, r5, r6, lr}
 8001d12:	4d0d      	ldr	r5, [pc, #52]	; (8001d48 <__libc_init_array+0x38>)
 8001d14:	4c0d      	ldr	r4, [pc, #52]	; (8001d4c <__libc_init_array+0x3c>)
 8001d16:	1b64      	subs	r4, r4, r5
 8001d18:	10a4      	asrs	r4, r4, #2
 8001d1a:	2600      	movs	r6, #0
 8001d1c:	42a6      	cmp	r6, r4
 8001d1e:	d109      	bne.n	8001d34 <__libc_init_array+0x24>
 8001d20:	4d0b      	ldr	r5, [pc, #44]	; (8001d50 <__libc_init_array+0x40>)
 8001d22:	4c0c      	ldr	r4, [pc, #48]	; (8001d54 <__libc_init_array+0x44>)
 8001d24:	f000 f818 	bl	8001d58 <_init>
 8001d28:	1b64      	subs	r4, r4, r5
 8001d2a:	10a4      	asrs	r4, r4, #2
 8001d2c:	2600      	movs	r6, #0
 8001d2e:	42a6      	cmp	r6, r4
 8001d30:	d105      	bne.n	8001d3e <__libc_init_array+0x2e>
 8001d32:	bd70      	pop	{r4, r5, r6, pc}
 8001d34:	f855 3b04 	ldr.w	r3, [r5], #4
 8001d38:	4798      	blx	r3
 8001d3a:	3601      	adds	r6, #1
 8001d3c:	e7ee      	b.n	8001d1c <__libc_init_array+0xc>
 8001d3e:	f855 3b04 	ldr.w	r3, [r5], #4
 8001d42:	4798      	blx	r3
 8001d44:	3601      	adds	r6, #1
 8001d46:	e7f2      	b.n	8001d2e <__libc_init_array+0x1e>
 8001d48:	08001d80 	.word	0x08001d80
 8001d4c:	08001d80 	.word	0x08001d80
 8001d50:	08001d80 	.word	0x08001d80
 8001d54:	08001d84 	.word	0x08001d84

08001d58 <_init>:
 8001d58:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001d5a:	bf00      	nop
 8001d5c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001d5e:	bc08      	pop	{r3}
 8001d60:	469e      	mov	lr, r3
 8001d62:	4770      	bx	lr

08001d64 <_fini>:
 8001d64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001d66:	bf00      	nop
 8001d68:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8001d6a:	bc08      	pop	{r3}
 8001d6c:	469e      	mov	lr, r3
 8001d6e:	4770      	bx	lr
